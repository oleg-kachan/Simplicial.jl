{
    "docs": [
        {
            "location": "/", 
            "text": "Simplicial.jl\n\n\nSimplicial\n is a \nJulia\n package for manipulating simplicial complexes and topological data analysis (TDA). The package defines types for \nCombinatorial Codes\n, \nSimplicial Complexes\n, \nFiltered Simplicial Complexes\n, and \nDirected Complexes\n.\n\n\n\n\nPackage Overview\n\n\n\n\nCombinatorial Codes\n\n\nCombinatorialCode\n Type\n\n\nOther features\n\n\nMorphisms of Neural Codes\n\n\n\n\n\n\nAbstract Simplicial Complexes\n\n\nSimplicial Complexes\n\n\nFiltered Simplicial Complexes\n\n\n\n\n\n\nDirected Complexes\n\n\n\n\n\n\nLibrary\n\n\n\n\nCombinatorial Codes\n\n\nPublic methods\n\n\nPrivate methods\n\n\nMorphisms\n\n\n\n\n\n\nSimplicial Complexes\n\n\nPublic Methods\n\n\nPrivate methods\n\n\n\n\n\n\nFiltered Simplicial Complexes\n\n\nPublic methods\n\n\nPrivate methods", 
            "title": "Home"
        }, 
        {
            "location": "/#simplicialjl", 
            "text": "Simplicial  is a  Julia  package for manipulating simplicial complexes and topological data analysis (TDA). The package defines types for  Combinatorial Codes ,  Simplicial Complexes ,  Filtered Simplicial Complexes , and  Directed Complexes .", 
            "title": "Simplicial.jl"
        }, 
        {
            "location": "/#package-overview", 
            "text": "Combinatorial Codes  CombinatorialCode  Type  Other features  Morphisms of Neural Codes    Abstract Simplicial Complexes  Simplicial Complexes  Filtered Simplicial Complexes    Directed Complexes", 
            "title": "Package Overview"
        }, 
        {
            "location": "/#library", 
            "text": "Combinatorial Codes  Public methods  Private methods  Morphisms    Simplicial Complexes  Public Methods  Private methods    Filtered Simplicial Complexes  Public methods  Private methods", 
            "title": "Library"
        }, 
        {
            "location": "/man/combinatorialcodes/", 
            "text": "Combinatorial Codes\n\n\nDefinition:\n A \ncombinatorial code\n $C$ is a collection $C \\subseteq 2^{[n]}$ of \ncodewords\n, subsets of the vertex set $[n] = {1,\\dots,n}$. Generally, no further structure is assumed.\n\n\n\n\nCombinatorialCode\n Type\n\n\nCombinatorial codes are represented using the \nCombinatorialCode{T}\n type. Codewords are stored as \nSet{T}\ns, where \nT\n:Integer\n\n\njulia\n C = CombinatorialCode([[],[1],[1,2],[2,3]])\nSimplicial.CombinatorialCode{Int8}\nCode on [3] with 4 codewords\nC = {emptyset, 1, 1 2, 2 3}\n\n\n\n\nBy default, when a code is constructed, the smallest \nInt\n type that can store all the vertices. To use \nUInt\n types, pass the keyword argument \nsigned=false\n. To override the integer type, pass \nsquash_int_type=false\n to the constructor.\n\n\njulia\n D = CombinatorialCode([[],[1],[1,2],[2,3]], signed=false)\nSimplicial.CombinatorialCode{UInt8}\nCode on [3] with 4 codewords\nC = {emptyset, 1, 1 2, 2 3}\n\n\njulia\n D = CombinatorialCode([[],[1],[1,2],[2,3]], squash_int_type=false)\nSimplicial.CombinatorialCode{Int64}\nCode on [3] with 4 codewords\nC = {emptyset, 1, 1 2, 2 3}\n\n\n\n\n\n\nOther features\n\n\nCombinatorialCode\ns are \niterable\n:\n\n\njulia\n [length(c) for c in C]\n4-element Array{Int64,1}:\n 0\n 1\n 2\n 2\n\n\n\n\nA complete list of methods can be found \nhere\n.\n\n\n\n\nMorphisms of Neural Codes\n\n\nSeveral functions related to \nmorphisms of neural codes\n have been implemented. See the documentation \nhere\n.", 
            "title": "Combinatorial Codes"
        }, 
        {
            "location": "/man/combinatorialcodes/#combinatorial-codes", 
            "text": "Definition:  A  combinatorial code  $C$ is a collection $C \\subseteq 2^{[n]}$ of  codewords , subsets of the vertex set $[n] = {1,\\dots,n}$. Generally, no further structure is assumed.", 
            "title": "Combinatorial Codes"
        }, 
        {
            "location": "/man/combinatorialcodes/#combinatorialcode-type", 
            "text": "Combinatorial codes are represented using the  CombinatorialCode{T}  type. Codewords are stored as  Set{T} s, where  T :Integer  julia  C = CombinatorialCode([[],[1],[1,2],[2,3]])\nSimplicial.CombinatorialCode{Int8}\nCode on [3] with 4 codewords\nC = {emptyset, 1, 1 2, 2 3}  By default, when a code is constructed, the smallest  Int  type that can store all the vertices. To use  UInt  types, pass the keyword argument  signed=false . To override the integer type, pass  squash_int_type=false  to the constructor.  julia  D = CombinatorialCode([[],[1],[1,2],[2,3]], signed=false)\nSimplicial.CombinatorialCode{UInt8}\nCode on [3] with 4 codewords\nC = {emptyset, 1, 1 2, 2 3}\n\n\njulia  D = CombinatorialCode([[],[1],[1,2],[2,3]], squash_int_type=false)\nSimplicial.CombinatorialCode{Int64}\nCode on [3] with 4 codewords\nC = {emptyset, 1, 1 2, 2 3}", 
            "title": "CombinatorialCode Type"
        }, 
        {
            "location": "/man/combinatorialcodes/#other-features", 
            "text": "CombinatorialCode s are  iterable :  julia  [length(c) for c in C]\n4-element Array{Int64,1}:\n 0\n 1\n 2\n 2  A complete list of methods can be found  here .", 
            "title": "Other features"
        }, 
        {
            "location": "/man/combinatorialcodes/#morphisms-of-neural-codes", 
            "text": "Several functions related to  morphisms of neural codes  have been implemented. See the documentation  here .", 
            "title": "Morphisms of Neural Codes"
        }, 
        {
            "location": "/man/simplicialcomplexes/", 
            "text": "Abstract Simplicial Complexes\n\n\nThis package provides types for \nSimplicial Complexes\n and \nFiltered Simplicial Complexes\n.\n\n\n\n\nSimplicial Complexes\n\n\nDefinition:\n A \nsimplicial complex\n $(V,\\Delta)$ is a finite set $V$, called the \nvertex set\n, together with a collection $\\Delta \\subseteq 2^{V}$ which is closed under subsets, i.e. if $\\sigma \\subseteq \\tau \\subseteq V$ are sets, and $\\tau \\in \\Delta$, then $\\sigma \\in \\Delta$. Typically $(V,D)$ is simply denoted $\\Delta$ as the vertex set is often understood. Note this definition allows \"false vertices\", i.e. vertices $v \\in V$ such that ${v}\\not\\in \\Delta$.\n\n\nSimplicial complexes are represented in \nSimplicial\n with the \nSimplicialComplex\n type.\n\n\njulia\n K = SimplicialComplex([[1,2,3],[2,4],[3,4]]);\n\njulia\n show(K)\nA 2-dimensional simplicial complex on 4 vertices 1 2 3 4\nThis complex has 3 facets:\nArray{Int16,1}[Int16[2, 4], Int16[3, 4], Int16[1, 2, 3]]\n\n\n\n\n\n\nExample Simplicial Complexes\n\n\nSeveral example simplicial complexes can be constructed by calling the appropriate function, for example\n\n\njulia\n K = TwoTorus()\nSimplicial.SimplicialComplex{Int8}\n2-dimensional simplicial complex on 7 vertices with 14 facets\n    V = {1, 2, 3, 4, 5, 6, 7}\nmax K = {1 2 4, 1 3 4, 2 3 5, 2 4 5, 1 3 6, 2 3 6, 1 5 6, 4 5 6, 1 2 7, 3 4 7, 1 5 7, 3 5 7, 2 6 7, 4 6 7}\n\n\n\n\nA complete list follows:\n\n\n#\n\n\nSimplicial.DunceHat\n \n \nMethod\n.\n\n\nDunceHat()\n\n\n\n\nA triangulation of the \ndunce hat\n\n\nsource\n\n\n#\n\n\nSimplicial.KleinBottle\n \n \nMethod\n.\n\n\nKleinBottle()\n\n\n\n\nThe minimal triangulation of the Klein bottle (8 vertices, 16 facets)\n\n\nsource\n\n\n#\n\n\nSimplicial.PoincareHomologyThreeSphere\n \n \nMethod\n.\n\n\nPoincareHomologyThreeSphere()\n\n\n\n\nA triangulation of the Poincare homology 3-sphere (16 vertices, 90 facets)\n\n\nThis is a manifold whose integral homology is identical to the ordinary 3-sphere, but it is not simply connected. In particular, its fundamental group is the binary icosahedral group, which has order 120. The triangulation given here has 16 vertices and is due to Bj\u00f6rner and Lutz [BL2000].\n\n\n[BL2000]    Anders Bj\u00f6rner and Frank H. Lutz, \u201cSimplicial manifolds, bistellar flips and a 16-vertex triangulation of the Poincar\u00e9 homology 3-sphere\u201d, Experiment. Math. 9 (2000), no. 2, 275-289.\n\n\nsource\n\n\n#\n\n\nSimplicial.TwoTorus\n \n \nMethod\n.\n\n\nTwoTorus()\n\n\n\n\nThe minimal triangulation of a two-torus (7 vertices, 14 facets)\n\n\nsource\n\n\n\n\nFiltered Simplicial Complexes\n\n\nA \nfiltered simplicial complex\n $(\\Delta,f)$ is a simplicial complex $\\Delta$ together with a \nfiltration function\n $f : \\Delta \\to R$ which is monotone, i.e. if $\\sigma \\subseteq \\tau \\in \\Delta$, then $f(\\sigma) \\le f(\\tau)$. Equivalently, a filtered simplicial complex is a sequence\n\n\n\n\n\n\\Delta_0 \\subseteq \\Delta_1 \\subseteq \\cdots \\subseteq \\Delta_t\n\n\n\n\n\nof simplicial complexes.", 
            "title": "Simplicial Complexes"
        }, 
        {
            "location": "/man/simplicialcomplexes/#abstract-simplicial-complexes", 
            "text": "This package provides types for  Simplicial Complexes  and  Filtered Simplicial Complexes .", 
            "title": "Abstract Simplicial Complexes"
        }, 
        {
            "location": "/man/simplicialcomplexes/#simplicial-complexes", 
            "text": "Definition:  A  simplicial complex  $(V,\\Delta)$ is a finite set $V$, called the  vertex set , together with a collection $\\Delta \\subseteq 2^{V}$ which is closed under subsets, i.e. if $\\sigma \\subseteq \\tau \\subseteq V$ are sets, and $\\tau \\in \\Delta$, then $\\sigma \\in \\Delta$. Typically $(V,D)$ is simply denoted $\\Delta$ as the vertex set is often understood. Note this definition allows \"false vertices\", i.e. vertices $v \\in V$ such that ${v}\\not\\in \\Delta$.  Simplicial complexes are represented in  Simplicial  with the  SimplicialComplex  type.  julia  K = SimplicialComplex([[1,2,3],[2,4],[3,4]]);\n\njulia  show(K)\nA 2-dimensional simplicial complex on 4 vertices 1 2 3 4\nThis complex has 3 facets:\nArray{Int16,1}[Int16[2, 4], Int16[3, 4], Int16[1, 2, 3]]", 
            "title": "Simplicial Complexes"
        }, 
        {
            "location": "/man/simplicialcomplexes/#example-simplicial-complexes", 
            "text": "Several example simplicial complexes can be constructed by calling the appropriate function, for example  julia  K = TwoTorus()\nSimplicial.SimplicialComplex{Int8}\n2-dimensional simplicial complex on 7 vertices with 14 facets\n    V = {1, 2, 3, 4, 5, 6, 7}\nmax K = {1 2 4, 1 3 4, 2 3 5, 2 4 5, 1 3 6, 2 3 6, 1 5 6, 4 5 6, 1 2 7, 3 4 7, 1 5 7, 3 5 7, 2 6 7, 4 6 7}  A complete list follows:  #  Simplicial.DunceHat     Method .  DunceHat()  A triangulation of the  dunce hat  source  #  Simplicial.KleinBottle     Method .  KleinBottle()  The minimal triangulation of the Klein bottle (8 vertices, 16 facets)  source  #  Simplicial.PoincareHomologyThreeSphere     Method .  PoincareHomologyThreeSphere()  A triangulation of the Poincare homology 3-sphere (16 vertices, 90 facets)  This is a manifold whose integral homology is identical to the ordinary 3-sphere, but it is not simply connected. In particular, its fundamental group is the binary icosahedral group, which has order 120. The triangulation given here has 16 vertices and is due to Bj\u00f6rner and Lutz [BL2000].  [BL2000]    Anders Bj\u00f6rner and Frank H. Lutz, \u201cSimplicial manifolds, bistellar flips and a 16-vertex triangulation of the Poincar\u00e9 homology 3-sphere\u201d, Experiment. Math. 9 (2000), no. 2, 275-289.  source  #  Simplicial.TwoTorus     Method .  TwoTorus()  The minimal triangulation of a two-torus (7 vertices, 14 facets)  source", 
            "title": "Example Simplicial Complexes"
        }, 
        {
            "location": "/man/simplicialcomplexes/#filtered-simplicial-complexes", 
            "text": "A  filtered simplicial complex  $(\\Delta,f)$ is a simplicial complex $\\Delta$ together with a  filtration function  $f : \\Delta \\to R$ which is monotone, i.e. if $\\sigma \\subseteq \\tau \\in \\Delta$, then $f(\\sigma) \\le f(\\tau)$. Equivalently, a filtered simplicial complex is a sequence   \n\\Delta_0 \\subseteq \\Delta_1 \\subseteq \\cdots \\subseteq \\Delta_t   of simplicial complexes.", 
            "title": "Filtered Simplicial Complexes"
        }, 
        {
            "location": "/man/directedcomplexes/", 
            "text": "Directed Complexes\n\n\nLet $V$ be a finite set. A sequence of size $k$ in $V$ (also known as $DirectedCodeword$) is a tuple $(v_1,v_2, \\dots, v_k)$ of $k$ elements in $V$, without repetitions. In other words, a directed codeword (a sequence) is a set together with a total order.  A sequence $s$ is a subsequence of a sequence $t$ ( $s\nt$) if $s$ can  obtained by removing some vertices from $t$, while keeping the same ordering of the remaining vertices. \n\n\nSimilarly, to a simplicial complex, a  $DirectedComplex$ is  defined as follows. \n\n\nDefinition:\n A \ndirected complex\n $D$ on a finite vertex set $V$, is a collection  of sequence  in $V$, closed under taking subsequences, i.e.   if $s = (v_1,\\dots,v_k) \\in D$, then every subsequence of $s$ is also in $D$.\n\n\nPackage simplicial provides the following types:  \n\n\n\n\n$DirectedCodeword$\n\n\n$DirectedComplex$\n\n\n$FiltrationOfDirectedComplexes$", 
            "title": "Directed Complexes"
        }, 
        {
            "location": "/man/directedcomplexes/#directed-complexes", 
            "text": "Let $V$ be a finite set. A sequence of size $k$ in $V$ (also known as $DirectedCodeword$) is a tuple $(v_1,v_2, \\dots, v_k)$ of $k$ elements in $V$, without repetitions. In other words, a directed codeword (a sequence) is a set together with a total order.  A sequence $s$ is a subsequence of a sequence $t$ ( $s t$) if $s$ can  obtained by removing some vertices from $t$, while keeping the same ordering of the remaining vertices.   Similarly, to a simplicial complex, a  $DirectedComplex$ is  defined as follows.   Definition:  A  directed complex  $D$ on a finite vertex set $V$, is a collection  of sequence  in $V$, closed under taking subsequences, i.e.   if $s = (v_1,\\dots,v_k) \\in D$, then every subsequence of $s$ is also in $D$.  Package simplicial provides the following types:     $DirectedCodeword$  $DirectedComplex$  $FiltrationOfDirectedComplexes$", 
            "title": "Directed Complexes"
        }, 
        {
            "location": "/lib/combinatorialcodes/", 
            "text": "Combinatorial Codes\n\n\n\n\nPublic methods\n\n\n#\n\n\nSimplicial.AbstractCombinatorialCode\n \n \nType\n.\n\n\nabstract type AbstractCombinatorialCode{T\n:Integer}\n\n\n\n\nThe abstract parent class for concrete implements of \ncombinatorial codes\n.\n\n\nsource\n\n\n#\n\n\nSimplicial.CombinatorialCode\n \n \nType\n.\n\n\nCombinatorialCode{T\n:Integer}\n\n\n\n\nA collection of subsets of $[n] = {1,...,n}$. Codewords are stored as \nSet{T}\n objects in an array.\n\n\nBy default, \nT\n is determined at object construction to be the smallest \nInt\n type that can store all the vertices; see notes below.\n\n\nConstructors\n\n\nCombinatorialCode(itr, [vertices=union(itr...)]; [squash_int_type=true], [signed=true])\n\n\n\n\nCollects the unique elements of iterable collection \nitr\n as codewords. If \nsquash_int_type\n is true, determines the smallest integer type which can store all the vertices; if \nsigned=false\n this will be a \nUInt\n type, otherwise it will be an \nInt\n type. Optional argument \nvertices\n allows creation of trivial neurons, i.e. neurons which never fire. Words are stored in graded reverse lexicographic order by their binary vector representation  (see \nlessequal_GrRevLex\n).\n\n\nCombinatorialCode(B::AbstractMatrix{Bool}; order=\nrows\n, kwargs...)\n\n\n\n\nInterprets rows of matrix \nB\n as codewords. Keyword argument \norder\n is either \nrows\n or \ncols\n to specify whether rows of \nB\n or columns of \nB\n should be interpreted as codewords.\n\n\nsource\n\n\n#\n\n\nBase.in\n \n \nMethod\n.\n\n\nin(sigma::itr, C::CombinatorialCode)\n\n\n\n\nTrue if \nsigma\n is a codeword in \nC\n\n\nsource\n\n\n#\n\n\nBase.transpose\n \n \nMethod\n.\n\n\ntranspose(C::CombinatorialCode)\n\n\n\n\nThe code obtained by transposing the matrix form of a code.\n\n\nUsage: \nC1 = transpose(C)\n or \nC1 = C'\n\n\nsource\n\n\n#\n\n\nSimplicial.BitArrayOfACombinatorialCode\n \n \nMethod\n.\n\n\nBitArrayOfACombinatorialCode(C)\n\n\n\n\n!!! Deprecated     This function is an alias to \nmatrix_form\n, use that instead.\n\n\nsource\n\n\n#\n\n\nSimplicial.add!\n \n \nMethod\n.\n\n\nadd!(C, sigma)\n\n\n\n\nIn-place version \nadd\n. Returns the resulting code.\n\n\nsource\n\n\n#\n\n\nSimplicial.add\n \n \nMethod\n.\n\n\nadd(C, sigma)\n\n\n\n\nReturn \nC\n if \nin(sigma, C)\n, otherwise construct a new code $C \u222a {sigma}$.\n\n\nsource\n\n\n#\n\n\nSimplicial.del!\n \n \nMethod\n.\n\n\ndel!(C, tau)\n\n\n\n\nIn-place version of \ndel\n. Returns the resulting code.\n\n\nsource\n\n\n#\n\n\nSimplicial.del\n \n \nMethod\n.\n\n\ndel(C, tau)\n\n\n\n\nCompute the deletion of \nsigma\n from \nC\n. Returns a new \nCombinatorialCode\n with the same vertex set.\n\n\nThe deletion is defined by $del_\u03c4(C) = {\u03c3 \u2216 \u03c4 : \u03c3 \u2208 C}$\n\n\nsource\n\n\n#\n\n\nSimplicial.link\n \n \nFunction\n.\n\n\nlink(code, sigma, tau=[])\n\n\n\n\nCompute the link of the \"on\" set \nsigma\n and the \"off\" set \ntau\n in \ncode\n, defined by\n\n\n$link_{\u03c3,\u03c4}(C) = {\u03c1 \u2286 [n] : \u03c1 \u2229 \u03c3 = \u03c1 \u2229 \u03c4 = \u2205, \u03c1 \u222a \u03c3 \u2208 C}$\n\n\nsource\n\n\n#\n\n\nSimplicial.matrix_form\n \n \nMethod\n.\n\n\nmatrix_form(C::CombinatorialCode)\n\n\n\n\nA \nBitMatrix\n representation of a code, with rows as codewords. Order of returned codewords matches that in \nC.words\n; assuming no one has been messing around with \nC\n's fields, these should be sorted using \nlessequal_GrRevLex\n.\n\n\nsource\n\n\n#\n\n\nSimplicial.sparse_matrix_form\n \n \nMethod\n.\n\n\nsparse_matrix_form(C::CombinatorialCode)\n\n\n\n\nA \nSparseMatrixCSC\n representation of \nC\n with \nBool\n entries; rows as codewords.\n\n\nOrder of returned codewords matches that in \nC.words\n; assuming no one has been messing around with \nC\n's fields, these should be sorted using \nlessequal_GrRevLex\n.\n\n\nsource\n\n\n#\n\n\nSimplicial.vertices\n \n \nMethod\n.\n\n\nvertices(C::CombinatorialCode)\n\n\n\n\nReturns the vertex set of \nC\n as a \nSet\n\n\nsource\n\n\n#\n\n\nSimplicial.cham\n \n \nMethod\n.\n\n\ncham(C, nu)\n\n\n\n\nReturns a vector of tuples \n(sigma,tau)\n such that \nlink(C, sigma, tau)\n is the full code on \nnu\n\n\nsource\n\n\n#\n\n\nSimplicial.intersection_completion\n \n \nMethod\n.\n\n\nintersection_completion(C)\n\n\n\n\nA new code consisting of all intersections of one or more codewords of \nC\n.\n\n\nsource\n\n\n#\n\n\nSimplicial.max_intersection_completion\n \n \nMethod\n.\n\n\nmax_intersection_completion(C)\n\n\n\n\nA new code consisting of all intersections of one or more maximal codewords of \nC\n.\n\n\nsource\n\n\n#\n\n\nSimplicial.union_completion\n \n \nMethod\n.\n\n\nunion_completion(C)\n\n\n\n\nThe union-completion of a combinatorial code \nC\n, which is \nC\n together with\n\n\nsource\n\n\n#\n\n\nSimplicial.union_product\n \n \nMethod\n.\n\n\nunion_product(C1, C2)\n\n\n\n\nCompute the union product of codes \nC1\n and \nC2\n, under the GrRevLex ordering on both codes.\n\n\nFor $A = {a_1,...,a_m}$ a code on $[d]$ and $B = {b_1,...,b_d}$ a code on $[n]$, the union product is a code on $[n]$ defined by $A \u2228 B = { \u22c3_{j \u2208 a_i} b_j : a_i \u2208 A}$\n\n\nMore simply, this is the code obtained from the nonzero entries of the product of the matrix forms of $A$ and $B$.\n\n\nsource\n\n\n#\n\n\nSimplicial.PseudoMonomial\n \n \nType\n.\n\n\nPseudoMonomial\n\n\n\n\nA polynomial of the form $\u220f\n{i\u2208\u03c3} x_i \u220f\n (1 - x_j)$\n\n\nsource\n\n\n#\n\n\nSimplicial.canonical_form\n \n \nMethod\n.\n\n\ncanonical_form(C::AbstractCombinatorialCode)\n\n\n\n\nThe set of minimal psuedomonomials that generate the ideal $I_C$. See \nThe Neural Ring\n. Per the conventions of that paper, this set excludes the \"boolean relations\" $x_i(1-x_i)$. Returns a \nVector\n of \nPseudoMonomial\ns\n\n\nThis is an implementation of Algorithm 1 from \nthis paper\n\n\nsource\n\n\n#\n\n\nSimplicial.pseudomonomialtype\n \n \nMethod\n.\n\n\npseudomonomialtype(p::PseudoMonomial)\n\n\n\n\nReturn the type of \np\n as classified in \nthe neural ring paper\n as an \nInt\n.\n\n\nType I:   $\u03c3 \u2260 \u2205, \u03c4 = \u2205$\n\n\nType II:  $\u03c3 \u2260 \u2205, \u03c4 \u2260 \u2205$\n\n\nType III: $\u03c3 = \u2205, \u03c4 \u2260 \u2205$\n\n\nReturns \n0\n if \np\n does not match one of the above.\n\n\nsource\n\n\n\n\nPrivate methods\n\n\nTo use these functions, you'll have to call \nSimplicial.function_name()\n\n\n\n\nMorphisms\n\n\n#\n\n\nIterTools.product\n \n \nMethod\n.\n\n\nproduct(C, D)\n\n\n\n\nThe category-theoretic product of two codes.\n\n\n$C \u00d7 D = {c \u222a d : c \u2208 C, d \u2208 D}$ where the codewords of $D$ are considered as subsets of ${n+1,\u2026,n+m}$\n\n\nsource\n\n\n#\n\n\nSimplicial.coproduct\n \n \nMethod\n.\n\n\ncoproduct(C, D)\n\n\n\n\nThe category-theoretic coproduct of two codes. More detailed latex definition is currently removed for compartibility reasons\n\n\nsource\n\n\n#\n\n\nSimplicial.core\n \n \nMethod\n.\n\n\ncore(C, sigma)\n\n\n\n\nThe core of \nsigma\n in \nC\n, defined by $core_C(\u03c3) = \u22c2_{\u03c4\u2208Tk_C(\u03c3)} \u03c4$.\n\n\nsource\n\n\n#\n\n\nSimplicial.delta\n \n \nFunction\n.\n\n\ndelta(n, k=0)\n\n\n\n\nReturns the combinatorial code corresponding to the simplex on \nn\n vertices, with vertex set \n(k+1):(k+n)\n\n\nsource\n\n\n#\n\n\nSimplicial.simplexmap\n \n \nMethod\n.\n\n\nsimplexmap(C; check_complete=true, check_max=true)\n\n\n\n\nReturns an integer \nm\n and array \nT\n of subsets such that \nC == trunksmorphism(delta(m),T)\n. Because checking if \nC\n is intersection-complete and/or checking if it has a unique maximal element is potentially time-consuming, the keyword arguments can be used to skip these checks.\n\n\ncheck_complete = false\n will skip computing the intersection completion of \nC\n and assume \nC\n is already intersection-complete; no guarantee what will be returned in this case.\n\n\ncheck_max = false\n will skip checking if \nC\n has a unique maximal codeword. Again, if \nC\n does not already have a unique maximal codeword, no guarantee what will be returned in this case.\n\n\nsource\n\n\n#\n\n\nSimplicial.trunk\n \n \nMethod\n.\n\n\ntrunk(C, sigma)\n\n\n\n\nThe trunk of \nsigma\n in \nC\n, defined by $Tk_C(\u03c3) = {c \u2208 C : \u03c3 \u2286 c}$\n\n\nsource\n\n\n#\n\n\nSimplicial.trunksmorphism\n \n \nMethod\n.\n\n\ntrunksmorphism(C, T)\n\n\n\n\nThe image of \nC\n under the morphism defined by the trunks in \nT\n.\n\n\nsource", 
            "title": "CombinatorialCode Type"
        }, 
        {
            "location": "/lib/combinatorialcodes/#combinatorial-codes", 
            "text": "", 
            "title": "Combinatorial Codes"
        }, 
        {
            "location": "/lib/combinatorialcodes/#public-methods", 
            "text": "#  Simplicial.AbstractCombinatorialCode     Type .  abstract type AbstractCombinatorialCode{T :Integer}  The abstract parent class for concrete implements of  combinatorial codes .  source  #  Simplicial.CombinatorialCode     Type .  CombinatorialCode{T :Integer}  A collection of subsets of $[n] = {1,...,n}$. Codewords are stored as  Set{T}  objects in an array.  By default,  T  is determined at object construction to be the smallest  Int  type that can store all the vertices; see notes below.  Constructors  CombinatorialCode(itr, [vertices=union(itr...)]; [squash_int_type=true], [signed=true])  Collects the unique elements of iterable collection  itr  as codewords. If  squash_int_type  is true, determines the smallest integer type which can store all the vertices; if  signed=false  this will be a  UInt  type, otherwise it will be an  Int  type. Optional argument  vertices  allows creation of trivial neurons, i.e. neurons which never fire. Words are stored in graded reverse lexicographic order by their binary vector representation  (see  lessequal_GrRevLex ).  CombinatorialCode(B::AbstractMatrix{Bool}; order= rows , kwargs...)  Interprets rows of matrix  B  as codewords. Keyword argument  order  is either  rows  or  cols  to specify whether rows of  B  or columns of  B  should be interpreted as codewords.  source  #  Base.in     Method .  in(sigma::itr, C::CombinatorialCode)  True if  sigma  is a codeword in  C  source  #  Base.transpose     Method .  transpose(C::CombinatorialCode)  The code obtained by transposing the matrix form of a code.  Usage:  C1 = transpose(C)  or  C1 = C'  source  #  Simplicial.BitArrayOfACombinatorialCode     Method .  BitArrayOfACombinatorialCode(C)  !!! Deprecated     This function is an alias to  matrix_form , use that instead.  source  #  Simplicial.add!     Method .  add!(C, sigma)  In-place version  add . Returns the resulting code.  source  #  Simplicial.add     Method .  add(C, sigma)  Return  C  if  in(sigma, C) , otherwise construct a new code $C \u222a {sigma}$.  source  #  Simplicial.del!     Method .  del!(C, tau)  In-place version of  del . Returns the resulting code.  source  #  Simplicial.del     Method .  del(C, tau)  Compute the deletion of  sigma  from  C . Returns a new  CombinatorialCode  with the same vertex set.  The deletion is defined by $del_\u03c4(C) = {\u03c3 \u2216 \u03c4 : \u03c3 \u2208 C}$  source  #  Simplicial.link     Function .  link(code, sigma, tau=[])  Compute the link of the \"on\" set  sigma  and the \"off\" set  tau  in  code , defined by  $link_{\u03c3,\u03c4}(C) = {\u03c1 \u2286 [n] : \u03c1 \u2229 \u03c3 = \u03c1 \u2229 \u03c4 = \u2205, \u03c1 \u222a \u03c3 \u2208 C}$  source  #  Simplicial.matrix_form     Method .  matrix_form(C::CombinatorialCode)  A  BitMatrix  representation of a code, with rows as codewords. Order of returned codewords matches that in  C.words ; assuming no one has been messing around with  C 's fields, these should be sorted using  lessequal_GrRevLex .  source  #  Simplicial.sparse_matrix_form     Method .  sparse_matrix_form(C::CombinatorialCode)  A  SparseMatrixCSC  representation of  C  with  Bool  entries; rows as codewords.  Order of returned codewords matches that in  C.words ; assuming no one has been messing around with  C 's fields, these should be sorted using  lessequal_GrRevLex .  source  #  Simplicial.vertices     Method .  vertices(C::CombinatorialCode)  Returns the vertex set of  C  as a  Set  source  #  Simplicial.cham     Method .  cham(C, nu)  Returns a vector of tuples  (sigma,tau)  such that  link(C, sigma, tau)  is the full code on  nu  source  #  Simplicial.intersection_completion     Method .  intersection_completion(C)  A new code consisting of all intersections of one or more codewords of  C .  source  #  Simplicial.max_intersection_completion     Method .  max_intersection_completion(C)  A new code consisting of all intersections of one or more maximal codewords of  C .  source  #  Simplicial.union_completion     Method .  union_completion(C)  The union-completion of a combinatorial code  C , which is  C  together with  source  #  Simplicial.union_product     Method .  union_product(C1, C2)  Compute the union product of codes  C1  and  C2 , under the GrRevLex ordering on both codes.  For $A = {a_1,...,a_m}$ a code on $[d]$ and $B = {b_1,...,b_d}$ a code on $[n]$, the union product is a code on $[n]$ defined by $A \u2228 B = { \u22c3_{j \u2208 a_i} b_j : a_i \u2208 A}$  More simply, this is the code obtained from the nonzero entries of the product of the matrix forms of $A$ and $B$.  source  #  Simplicial.PseudoMonomial     Type .  PseudoMonomial  A polynomial of the form $\u220f {i\u2208\u03c3} x_i \u220f  (1 - x_j)$  source  #  Simplicial.canonical_form     Method .  canonical_form(C::AbstractCombinatorialCode)  The set of minimal psuedomonomials that generate the ideal $I_C$. See  The Neural Ring . Per the conventions of that paper, this set excludes the \"boolean relations\" $x_i(1-x_i)$. Returns a  Vector  of  PseudoMonomial s  This is an implementation of Algorithm 1 from  this paper  source  #  Simplicial.pseudomonomialtype     Method .  pseudomonomialtype(p::PseudoMonomial)  Return the type of  p  as classified in  the neural ring paper  as an  Int .  Type I:   $\u03c3 \u2260 \u2205, \u03c4 = \u2205$  Type II:  $\u03c3 \u2260 \u2205, \u03c4 \u2260 \u2205$  Type III: $\u03c3 = \u2205, \u03c4 \u2260 \u2205$  Returns  0  if  p  does not match one of the above.  source", 
            "title": "Public methods"
        }, 
        {
            "location": "/lib/combinatorialcodes/#private-methods", 
            "text": "To use these functions, you'll have to call  Simplicial.function_name()", 
            "title": "Private methods"
        }, 
        {
            "location": "/lib/combinatorialcodes/#morphisms", 
            "text": "#  IterTools.product     Method .  product(C, D)  The category-theoretic product of two codes.  $C \u00d7 D = {c \u222a d : c \u2208 C, d \u2208 D}$ where the codewords of $D$ are considered as subsets of ${n+1,\u2026,n+m}$  source  #  Simplicial.coproduct     Method .  coproduct(C, D)  The category-theoretic coproduct of two codes. More detailed latex definition is currently removed for compartibility reasons  source  #  Simplicial.core     Method .  core(C, sigma)  The core of  sigma  in  C , defined by $core_C(\u03c3) = \u22c2_{\u03c4\u2208Tk_C(\u03c3)} \u03c4$.  source  #  Simplicial.delta     Function .  delta(n, k=0)  Returns the combinatorial code corresponding to the simplex on  n  vertices, with vertex set  (k+1):(k+n)  source  #  Simplicial.simplexmap     Method .  simplexmap(C; check_complete=true, check_max=true)  Returns an integer  m  and array  T  of subsets such that  C == trunksmorphism(delta(m),T) . Because checking if  C  is intersection-complete and/or checking if it has a unique maximal element is potentially time-consuming, the keyword arguments can be used to skip these checks.  check_complete = false  will skip computing the intersection completion of  C  and assume  C  is already intersection-complete; no guarantee what will be returned in this case.  check_max = false  will skip checking if  C  has a unique maximal codeword. Again, if  C  does not already have a unique maximal codeword, no guarantee what will be returned in this case.  source  #  Simplicial.trunk     Method .  trunk(C, sigma)  The trunk of  sigma  in  C , defined by $Tk_C(\u03c3) = {c \u2208 C : \u03c3 \u2286 c}$  source  #  Simplicial.trunksmorphism     Method .  trunksmorphism(C, T)  The image of  C  under the morphism defined by the trunks in  T .  source", 
            "title": "Morphisms"
        }, 
        {
            "location": "/lib/simplicialcomplexes/", 
            "text": "Simplicial Complexes\n\n\n\n\nPublic Methods\n\n\n#\n\n\nSimplicial.AbstractSimplicialComplex\n \n \nType\n.\n\n\nabstract type AbstractSimplicialComplex\n\n\n\n\nThe abstract parent class for all concrete implementations of \nabstract simplicial complexes\n (a regrettable clash of terminology).\n\n\nsource\n\n\n#\n\n\nSimplicial.SimplicialComplex\n \n \nType\n.\n\n\nSimplicialComplex{T}\n\n\n\n\nStores an abstract simplicial complex with vertices of type \nT\n by storing a list of its facets.\n\n\nConstructors\n\n\nSimplicialComplex(itr, vertices=union(itr...))\n\n\n\n\nUses the maximal elements of \nitr\n as facets. Optional argument \nvertices\n can specify vertex set if some vertices do not appear as faces. The vertices are of type \neltype(vertices)\n; if this is a subtype of \nInteger\n the smallest type which can store those values is used.\n\n\nSimplicialComplex(B)\n\n\n\n\nInterprets rows of binary matrix \nB\n as codewords.\n\n\nsource\n\n\n#\n\n\nSimplicial.add\n \n \nMethod\n.\n\n\nadd(K::SimplicialComplex, sigma)\n\n\n\n\nAdd face \nsigma\n to simplicial complex \nK\n. If \nsigma\n is already a face of \nK\n, returns \nK\n, otherwise returns a new object.\n\n\nsource\n\n\n#\n\n\nSimplicial.del!\n \n \nMethod\n.\n\n\ndel!(K, tau)\n\n\n\n\nIn-place version of \ndel\n\n\nsource\n\n\n#\n\n\nSimplicial.del\n \n \nMethod\n.\n\n\ndel(K, tau)\n\n\n\n\nThe deletion of \ntau\n from \nK\n. This is the set faces in \nK\n which are \nnot\n cofaces of \ntau\n. Returned complex has same vertex type and vertex set as \nK\n.\n\n\n$del_\u03c4(K) = {\u03c3 \u2208 K : \u03c4 \u228f\u0338 \u03c3}$\n\n\nFor \"deletion\" in the sense \"faces which do not intersect \ntau\n\", compute the complement of \ntau\n in \nK\n's vertex set and use \nres\n to restrict to that set.\n\n\nsource\n\n\n#\n\n\nSimplicial.dim\n \n \nMethod\n.\n\n\ndim(K)\n\n\n\n\nThe dimension of \nK\n, defined as the maximum size of a face of \nK\n minus 1.\n\n\nIf \nK\n is the void complex (i.e. \nK\n has no faces), returns \n-2\n for type stability (this function always returns an \nInt\n); mathematically a sensible value would be \n-Inf\n.\n\n\nsource\n\n\n#\n\n\nSimplicial.dimension\n \n \nFunction\n.\n\n\ndimension(K)\n\n\n\n\nAlias for \ndim\n\n\nsource\n\n\n#\n\n\nSimplicial.fvector\n \n \nMethod\n.\n\n\nfvector(K)\n\n\n\n\nCompute the f-vector of the given simplicial complex.\n\n\nThe f-vector of a simplicial complex is the vector $(f_0, f_1, ..., f_{d+1})$ where $f_i$ is the number of faces of cardinality $i$ (i.e. dimension $i - 1$).\n\n\nsource\n\n\n#\n\n\nSimplicial.hvector\n \n \nMethod\n.\n\n\nhvector(K)\nhvector(fv)\n\n\n\n\nCompute the h-vector of complex \nK\n by calling \nfvector(K)\n, or compute the h-vector corresponding to vector \nfv\n.\n\n\nSee \nfvector\n for details on the f-vector of a simplicial complex. The f-polynomial is the polynomial $F(x)$ with coefficient $f_i$ in degree $d+1-i$; the h-vector is the coefficients of $F(x-1)$ in decreasing order of degree.\n\n\nsource\n\n\n#\n\n\nSimplicial.link\n \n \nMethod\n.\n\n\nlink(K::SimplicialComplex, sigma)\n\n\n\n\nThe link of \nsigma\n in \nK\n.\n\n\n$link_\u03c3(K) = {\u03c4 \u2208 K : \u03c3 \u2229 \u03c4 = \u2205, \u03c3 \u222a \u03c4 \u2208 K}$\n\n\nsource\n\n\n#\n\n\nSimplicial.res\n \n \nMethod\n.\n\n\nres(K, Vprime)\n\n\n\n\nThe restriction of \nK\n to \nVprime\n.\n\n\n$res_{V'}(K) = {\u03c3 \u2208 K : \u03c3 \u2286 V'} = {\u03c3 \u2229 V' : \u03c3 \u2208 K}$\n\n\nsource\n\n\n#\n\n\nSimplicial.IrrelevantComplex\n \n \nMethod\n.\n\n\nIrrelevantComplex(vertices=Set{Int}())\nIrrelevantComplex(K::AbstractSimplicialComplex)\n\n\n\n\nThe irrelevant complex, which has exactly one face, the empty set. Vertex set can be optionally specified\n\n\nThe second form returns a simplicial complex of the same type and vertex set as \nK\n.\n\n\nsource\n\n\n#\n\n\nSimplicial.VoidComplex\n \n \nMethod\n.\n\n\nVoidComplex(vertices=Set{Int}())\nVoidComplex(K::AbstractSimplicialComplex)\n\n\n\n\nThe void simplicial complex, which has no faces (not even the empty set), with specified vertex set (default is empty).\n\n\nThe second form returns a simplicial complex of the same type and vertex set as \nK\n\n\nsource\n\n\n#\n\n\nSimplicial.alexander_dual\n \n \nMethod\n.\n\n\nalexader_dual(SC::SimplicialComplex)\n\n\n\n\nReturns the Alexander dual simplicial complex to \nSC\n.\n\n\n$dual \u0394 = {V \u2216 c : c \u2209 \u0394}$\n\n\n!!! Implementation note     Currently uses a highly inefficient algorithm, unsuitable for larger complexes.\n\n\nsource\n\n\n#\n\n\nSimplicial.polar_complex\n \n \nFunction\n.\n\n\npolar_complex(C)\n\n\n\n\nConstructs the polar complex $\u0393(C)$ for the given code.\n\n\n!!! Implementation notes     Vertex set is \nV = union(vertices(C), map(-,vertices(C)))\n. This can have strange     results if the vertex type of \nC\n is unsigned and the size of the vertex set is large.\n\n\nsource\n\n\n\n\nPrivate methods\n\n\nTo use these functions, you'll have to call \nSimplicial.function_name()\n\n\n#\n\n\nSimplicial.DeleteRedundantFacets!\n \n \nMethod\n.\n\n\nDeleteRedundantFacets!(facets::Vector)\n\n\n\n\nDeletes redundant sets in \nfacets\n in-place. A set is redundant if it is a subset (or equal to) a later set.\n\n\nsource", 
            "title": "SimplicialComplex Type"
        }, 
        {
            "location": "/lib/simplicialcomplexes/#simplicial-complexes", 
            "text": "", 
            "title": "Simplicial Complexes"
        }, 
        {
            "location": "/lib/simplicialcomplexes/#public-methods", 
            "text": "#  Simplicial.AbstractSimplicialComplex     Type .  abstract type AbstractSimplicialComplex  The abstract parent class for all concrete implementations of  abstract simplicial complexes  (a regrettable clash of terminology).  source  #  Simplicial.SimplicialComplex     Type .  SimplicialComplex{T}  Stores an abstract simplicial complex with vertices of type  T  by storing a list of its facets.  Constructors  SimplicialComplex(itr, vertices=union(itr...))  Uses the maximal elements of  itr  as facets. Optional argument  vertices  can specify vertex set if some vertices do not appear as faces. The vertices are of type  eltype(vertices) ; if this is a subtype of  Integer  the smallest type which can store those values is used.  SimplicialComplex(B)  Interprets rows of binary matrix  B  as codewords.  source  #  Simplicial.add     Method .  add(K::SimplicialComplex, sigma)  Add face  sigma  to simplicial complex  K . If  sigma  is already a face of  K , returns  K , otherwise returns a new object.  source  #  Simplicial.del!     Method .  del!(K, tau)  In-place version of  del  source  #  Simplicial.del     Method .  del(K, tau)  The deletion of  tau  from  K . This is the set faces in  K  which are  not  cofaces of  tau . Returned complex has same vertex type and vertex set as  K .  $del_\u03c4(K) = {\u03c3 \u2208 K : \u03c4 \u228f\u0338 \u03c3}$  For \"deletion\" in the sense \"faces which do not intersect  tau \", compute the complement of  tau  in  K 's vertex set and use  res  to restrict to that set.  source  #  Simplicial.dim     Method .  dim(K)  The dimension of  K , defined as the maximum size of a face of  K  minus 1.  If  K  is the void complex (i.e.  K  has no faces), returns  -2  for type stability (this function always returns an  Int ); mathematically a sensible value would be  -Inf .  source  #  Simplicial.dimension     Function .  dimension(K)  Alias for  dim  source  #  Simplicial.fvector     Method .  fvector(K)  Compute the f-vector of the given simplicial complex.  The f-vector of a simplicial complex is the vector $(f_0, f_1, ..., f_{d+1})$ where $f_i$ is the number of faces of cardinality $i$ (i.e. dimension $i - 1$).  source  #  Simplicial.hvector     Method .  hvector(K)\nhvector(fv)  Compute the h-vector of complex  K  by calling  fvector(K) , or compute the h-vector corresponding to vector  fv .  See  fvector  for details on the f-vector of a simplicial complex. The f-polynomial is the polynomial $F(x)$ with coefficient $f_i$ in degree $d+1-i$; the h-vector is the coefficients of $F(x-1)$ in decreasing order of degree.  source  #  Simplicial.link     Method .  link(K::SimplicialComplex, sigma)  The link of  sigma  in  K .  $link_\u03c3(K) = {\u03c4 \u2208 K : \u03c3 \u2229 \u03c4 = \u2205, \u03c3 \u222a \u03c4 \u2208 K}$  source  #  Simplicial.res     Method .  res(K, Vprime)  The restriction of  K  to  Vprime .  $res_{V'}(K) = {\u03c3 \u2208 K : \u03c3 \u2286 V'} = {\u03c3 \u2229 V' : \u03c3 \u2208 K}$  source  #  Simplicial.IrrelevantComplex     Method .  IrrelevantComplex(vertices=Set{Int}())\nIrrelevantComplex(K::AbstractSimplicialComplex)  The irrelevant complex, which has exactly one face, the empty set. Vertex set can be optionally specified  The second form returns a simplicial complex of the same type and vertex set as  K .  source  #  Simplicial.VoidComplex     Method .  VoidComplex(vertices=Set{Int}())\nVoidComplex(K::AbstractSimplicialComplex)  The void simplicial complex, which has no faces (not even the empty set), with specified vertex set (default is empty).  The second form returns a simplicial complex of the same type and vertex set as  K  source  #  Simplicial.alexander_dual     Method .  alexader_dual(SC::SimplicialComplex)  Returns the Alexander dual simplicial complex to  SC .  $dual \u0394 = {V \u2216 c : c \u2209 \u0394}$  !!! Implementation note     Currently uses a highly inefficient algorithm, unsuitable for larger complexes.  source  #  Simplicial.polar_complex     Function .  polar_complex(C)  Constructs the polar complex $\u0393(C)$ for the given code.  !!! Implementation notes     Vertex set is  V = union(vertices(C), map(-,vertices(C))) . This can have strange     results if the vertex type of  C  is unsigned and the size of the vertex set is large.  source", 
            "title": "Public Methods"
        }, 
        {
            "location": "/lib/simplicialcomplexes/#private-methods", 
            "text": "To use these functions, you'll have to call  Simplicial.function_name()  #  Simplicial.DeleteRedundantFacets!     Method .  DeleteRedundantFacets!(facets::Vector)  Deletes redundant sets in  facets  in-place. A set is redundant if it is a subset (or equal to) a later set.  source", 
            "title": "Private methods"
        }, 
        {
            "location": "/lib/filteredsimplicialcomplexes/", 
            "text": "Filtered Simplicial Complexes\n\n\n\n\nPublic methods\n\n\n\n\nPrivate methods\n\n\nTo use these functions, you'll have to call \nSimplicial.function_name()", 
            "title": "FiltrationOfSimplicialComplexes Type"
        }, 
        {
            "location": "/lib/filteredsimplicialcomplexes/#filtered-simplicial-complexes", 
            "text": "", 
            "title": "Filtered Simplicial Complexes"
        }, 
        {
            "location": "/lib/filteredsimplicialcomplexes/#public-methods", 
            "text": "", 
            "title": "Public methods"
        }, 
        {
            "location": "/lib/filteredsimplicialcomplexes/#private-methods", 
            "text": "To use these functions, you'll have to call  Simplicial.function_name()", 
            "title": "Private methods"
        }, 
        {
            "location": "/lib/directedcomplexes/", 
            "text": "Directed Complexes\n\n\n\n\nPublic methods\n\n\n#\n\n\nSimplicial.DirectedCodeword\n \n \nType\n.\n\n\nDirectedCodeword is the type that encodes (ordered) sequences of vertices\n\n\nsource\n\n\n#\n\n\nSimplicial.DirectedComplex\n \n \nMethod\n.\n\n\nThis function takes a matrix (of integers or Floats and produces a directed complex )\n\n\nsource\n\n\n#\n\n\nBase.:\n \n \nMethod\n.\n\n\nUsage: a\nb This boolean operation returns true if a is a proper subsequence of b.\n\n\nsource\n\n\n#\n\n\nBase.:\n=\n \n \nMethod\n.\n\n\nissubsequence(a,b) a.k.a. \n=(a,b)  determines if the sequence a is a subsequence of sequence b\n\n\nsource\n\n\n#\n\n\nSimplicial.Matrix2Permutations\n \n \nMethod\n.\n\n\nfunction  Matrix2Permutations(A::Matrix)::Matrix   This utility function takes a matrix A of real numbers and returns the matrix RowOrdering of integers, so that   RowOrdering[i,j] = the order of the element A[i,j] in the i-th row of A   Usage: RowOrdering=Matrix2Permutations(A);\n\n\nsource\n\n\n#\n\n\nSimplicial.dim\n \n \nMethod\n.\n\n\nThe dimension of a complex\n\n\nsource\n\n\n#\n\n\nSimplicial.issubsequence\n \n \nMethod\n.\n\n\nThe following name added for compartibility with the older code\n\n\nsource\n\n\n#\n\n\nSimplicial.BettiNumbers\n \n \nFunction\n.\n\n\nbeta=BettiNumbers(D::DirectedComplex,maximaldimension=Inf)\n\n\nThis function returns the Betti numbers of the homology of a (so far only pure) directed complex\n\n\nThis is a very crude way to compute directed homology \u2013 this does not use any tricks, just the definition and the built-in rank function that may fail to work properly on large enough matrices. Use with caution. Works as prescribed on small enough complexes.\n\n\nHere the length of beta is equal to maximaldimension+1, beta[1] is 0-th Betti number  and beta[P.dim+1] is the P.dim-dimensional Betti number maximaldimension is an optional parameter to restrict the maximal possible dimension of homology to compute\n\n\nsource\n\n\n\n\nPrivate methods\n\n\nTo use these functions, you'll have to call \nSimplicial.function_name()\n\n\n#\n\n\nBase.show\n \n \nMethod\n.\n\n\nshow(FS::FiltrationOfSimplicialComplexes)\n\n\n\n\nsource\n\n\n#\n\n\nSimplicial.DowkerComplex\n \n \nFunction\n.\n\n\nDowkerComplex(A,maxdensity=1)\n\nThis returns the Dowker complex of a rectangular matrix A\nNormal usage of this function should be\n\nFS, GraphDensity=DowkerComplex(A);\nor\nFS, GraphDensity=DowkerComplex(A,maxdensity);\n\nHere FS is of the type FiltrationOfSimplicialComplexes\nAnd GraphDensity is an array of real numbers of length =F.depth\nwhere each number GraphDensity[i] represents the graph density at the simplicial complex \u0394_i in the filtration\n\n\n\n\nsource\n\n\n#\n\n\nSimplicial.Skeleton\n \n \nMethod\n.\n\n\nSkeleton(FS::FiltrationOfSimplicialComplexes,dim::Int)::FiltrationOfSimplicialComplexes\nThis Funcion takes a filtration of simplicial complexes and produces a filtration of their skeletons\n\n\n\n\nsource\n\n\n#\n\n\nSimplicial.Skeleton_OLD\n \n \nMethod\n.\n\n\nSkeleton_OLD(FS::FiltrationOfSimplicialComplexes,dim::Int)::FiltrationOfSimplicialComplexes\nThis Function takes a filtration of simplicial complexes and produces a filtration of their skeletons\nThis implementation is \nnaive\n, old and very inefficient on large skeleta\n\n\n\n\nsource\n\n\n#\n\n\nSimplicial.FaceBirthpush!\n \n \nMethod\n.\n\n\nFaceBirthpush!(ListOfFaces::Array{CodeWord,1},births::Array{Int,1},AddedFace::CodeWord,AssignedBirth::Int)\n\n\n\n\nsource", 
            "title": "DirectedComplex Type"
        }, 
        {
            "location": "/lib/directedcomplexes/#directed-complexes", 
            "text": "", 
            "title": "Directed Complexes"
        }, 
        {
            "location": "/lib/directedcomplexes/#public-methods", 
            "text": "#  Simplicial.DirectedCodeword     Type .  DirectedCodeword is the type that encodes (ordered) sequences of vertices  source  #  Simplicial.DirectedComplex     Method .  This function takes a matrix (of integers or Floats and produces a directed complex )  source  #  Base.:     Method .  Usage: a b This boolean operation returns true if a is a proper subsequence of b.  source  #  Base.: =     Method .  issubsequence(a,b) a.k.a.  =(a,b)  determines if the sequence a is a subsequence of sequence b  source  #  Simplicial.Matrix2Permutations     Method .  function  Matrix2Permutations(A::Matrix)::Matrix   This utility function takes a matrix A of real numbers and returns the matrix RowOrdering of integers, so that   RowOrdering[i,j] = the order of the element A[i,j] in the i-th row of A   Usage: RowOrdering=Matrix2Permutations(A);  source  #  Simplicial.dim     Method .  The dimension of a complex  source  #  Simplicial.issubsequence     Method .  The following name added for compartibility with the older code  source  #  Simplicial.BettiNumbers     Function .  beta=BettiNumbers(D::DirectedComplex,maximaldimension=Inf)  This function returns the Betti numbers of the homology of a (so far only pure) directed complex  This is a very crude way to compute directed homology \u2013 this does not use any tricks, just the definition and the built-in rank function that may fail to work properly on large enough matrices. Use with caution. Works as prescribed on small enough complexes.  Here the length of beta is equal to maximaldimension+1, beta[1] is 0-th Betti number  and beta[P.dim+1] is the P.dim-dimensional Betti number maximaldimension is an optional parameter to restrict the maximal possible dimension of homology to compute  source", 
            "title": "Public methods"
        }, 
        {
            "location": "/lib/directedcomplexes/#private-methods", 
            "text": "To use these functions, you'll have to call  Simplicial.function_name()  #  Base.show     Method .  show(FS::FiltrationOfSimplicialComplexes)  source  #  Simplicial.DowkerComplex     Function .  DowkerComplex(A,maxdensity=1)\n\nThis returns the Dowker complex of a rectangular matrix A\nNormal usage of this function should be\n\nFS, GraphDensity=DowkerComplex(A);\nor\nFS, GraphDensity=DowkerComplex(A,maxdensity);\n\nHere FS is of the type FiltrationOfSimplicialComplexes\nAnd GraphDensity is an array of real numbers of length =F.depth\nwhere each number GraphDensity[i] represents the graph density at the simplicial complex \u0394_i in the filtration  source  #  Simplicial.Skeleton     Method .  Skeleton(FS::FiltrationOfSimplicialComplexes,dim::Int)::FiltrationOfSimplicialComplexes\nThis Funcion takes a filtration of simplicial complexes and produces a filtration of their skeletons  source  #  Simplicial.Skeleton_OLD     Method .  Skeleton_OLD(FS::FiltrationOfSimplicialComplexes,dim::Int)::FiltrationOfSimplicialComplexes\nThis Function takes a filtration of simplicial complexes and produces a filtration of their skeletons\nThis implementation is  naive , old and very inefficient on large skeleta  source  #  Simplicial.FaceBirthpush!     Method .  FaceBirthpush!(ListOfFaces::Array{CodeWord,1},births::Array{Int,1},AddedFace::CodeWord,AssignedBirth::Int)  source", 
            "title": "Private methods"
        }, 
        {
            "location": "/lib/otherfunctions/", 
            "text": "Other functions\n\n\nOther miscellaneous functions provided by this package, or used internally.\n\n\n\n\nPublic methods\n\n\n\n\nPrivate methods\n\n\nThese are generally intended for internal use, but if you really want to use one, its use must be qualified: \nSimplicial.function_name()\n\n\n#\n\n\nSimplicial.binary_to_set\n \n \nMethod\n.\n\n\nbinary_to_set(b, V)\n\n\n\n\nConverts binary vector \nb\n into a subset of \nV\n, reresented as a vector.\n\n\nsource\n\n\n#\n\n\nSimplicial.insert_sorted!\n \n \nMethod\n.\n\n\ninsert_sorted!(a::Vector{T}, item::T, lt)\n\n\n\n\nInserts \nitem\n into sorted vector \na\n in the appropriate position, according to the order \nlt\n. Danger! Requires \nitem\n to be of type \nT\n.\n\n\nsource\n\n\n#\n\n\nSimplicial.lessequal_GrRevLex\n \n \nMethod\n.\n\n\nlessequal_GrRevLex(a, b)\n\n\n\n\nTrue if $a \n=_GrRevLex b$. See \ngraded reverse lexicographic order\n.\n\n\nCan be used to \nsortrows\n a matrix with boolean entries (i.e. \na\n and \nb\n are both \nAbstractVector{Bool}\n types) or to sort a list of sets (i.e. \na\n and \nb\n are \nVector\ns or \nSet\ns)\n\n\nsource\n\n\n#\n\n\nSimplicial.list_to_bitmatrix\n \n \nFunction\n.\n\n\nlist_to_bitmatrix(L, V=collect(union(L...)))\n\n\n\n\nRepresents \nL\n as a binary matrix where the \ni\nth row is the logical index of the \ni\nth list in \nL\n to the vertex set \nV\n. Does not attempt any pruning of redundant faces; to get unique rows from the result \nB\n, use \nunique(B, 1)\n\n\nsource\n\n\n#\n\n\nSimplicial.set_to_binary\n \n \nMethod\n.\n\n\nset_to_binary(s, V)\n\n\n\n\nConverts set \ns\n into a logical index to the (ordered) vertex set \nV\n\n\nsource\n\n\n#\n\n\nSimplicial.smallest_int_type\n \n \nMethod\n.\n\n\nsmallest_int_type(ints...)\n\n\n\n\nReturn the smallest integer type that can store all the given integers.\n\n\nsource\n\n\n#\n\n\nSimplicial.smallest_uint_type\n \n \nMethod\n.\n\n\nsmallest_uint_type(ints...)\n\n\n\n\nReturn the smallest unsigned integer type that can store all the given integers\n\n\nsource\n\n\n#\n\n\nSimplicial.subset_rows\n \n \nMethod\n.\n\n\nsubset_rows(B)\n\n\n\n\nWhich rows in binary matrix \nB\n have support contained in the support of another row. Returns a vector \nV\n with \nV[i] = 0\n if row \ni\n is not contained in any other row; otherwise, \nV[i] = j\n means that set \ni\n is a subset of set \nj\n. If row \ni\n is contained in multiple other rows, no guarantee about which will be returned.\n\n\nsource", 
            "title": "Additional Functions"
        }, 
        {
            "location": "/lib/otherfunctions/#other-functions", 
            "text": "Other miscellaneous functions provided by this package, or used internally.", 
            "title": "Other functions"
        }, 
        {
            "location": "/lib/otherfunctions/#public-methods", 
            "text": "", 
            "title": "Public methods"
        }, 
        {
            "location": "/lib/otherfunctions/#private-methods", 
            "text": "These are generally intended for internal use, but if you really want to use one, its use must be qualified:  Simplicial.function_name()  #  Simplicial.binary_to_set     Method .  binary_to_set(b, V)  Converts binary vector  b  into a subset of  V , reresented as a vector.  source  #  Simplicial.insert_sorted!     Method .  insert_sorted!(a::Vector{T}, item::T, lt)  Inserts  item  into sorted vector  a  in the appropriate position, according to the order  lt . Danger! Requires  item  to be of type  T .  source  #  Simplicial.lessequal_GrRevLex     Method .  lessequal_GrRevLex(a, b)  True if $a  =_GrRevLex b$. See  graded reverse lexicographic order .  Can be used to  sortrows  a matrix with boolean entries (i.e.  a  and  b  are both  AbstractVector{Bool}  types) or to sort a list of sets (i.e.  a  and  b  are  Vector s or  Set s)  source  #  Simplicial.list_to_bitmatrix     Function .  list_to_bitmatrix(L, V=collect(union(L...)))  Represents  L  as a binary matrix where the  i th row is the logical index of the  i th list in  L  to the vertex set  V . Does not attempt any pruning of redundant faces; to get unique rows from the result  B , use  unique(B, 1)  source  #  Simplicial.set_to_binary     Method .  set_to_binary(s, V)  Converts set  s  into a logical index to the (ordered) vertex set  V  source  #  Simplicial.smallest_int_type     Method .  smallest_int_type(ints...)  Return the smallest integer type that can store all the given integers.  source  #  Simplicial.smallest_uint_type     Method .  smallest_uint_type(ints...)  Return the smallest unsigned integer type that can store all the given integers  source  #  Simplicial.subset_rows     Method .  subset_rows(B)  Which rows in binary matrix  B  have support contained in the support of another row. Returns a vector  V  with  V[i] = 0  if row  i  is not contained in any other row; otherwise,  V[i] = j  means that set  i  is a subset of set  j . If row  i  is contained in multiple other rows, no guarantee about which will be returned.  source", 
            "title": "Private methods"
        }
    ]
}