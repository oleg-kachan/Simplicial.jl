{
    "docs": [
        {
            "location": "/", 
            "text": "Simplicial.jl\n\n\nSimplicial\n is a \nJulia\n package for manipulating simplicial complexes and topological data analysis (TDA). The package defines types for \nCombinatorial Codes\n, \nSimplicial Complexes\n, \nFiltered Simplicial Complexes\n, and \nDirected Complexes\n.\n\n\n\n\nPackage Overview\n\n\n\n\nCombinatorial Codes\n\n\nCombinatorialCode\n Type\n\n\nOther features\n\n\n\n\n\n\nAbstract Simplicial Complexes\n\n\nSimplicial Complexes\n\n\nFiltered Simplicial Complexes\n\n\n\n\n\n\nDirected Complexes\n\n\n\n\n\n\nLibrary\n\n\n\n\nCombinatorial Codes\n\n\nPublic methods\n\n\nPrivate methods\n\n\n\n\n\n\nSimplicial Complexes\n\n\nPublic Methods\n\n\nPrivate methods\n\n\n\n\n\n\nFiltered Simplicial Complexes\n\n\nPublic methods\n\n\nPrivate methods", 
            "title": "Home"
        }, 
        {
            "location": "/#simplicialjl", 
            "text": "Simplicial  is a  Julia  package for manipulating simplicial complexes and topological data analysis (TDA). The package defines types for  Combinatorial Codes ,  Simplicial Complexes ,  Filtered Simplicial Complexes , and  Directed Complexes .", 
            "title": "Simplicial.jl"
        }, 
        {
            "location": "/#package-overview", 
            "text": "Combinatorial Codes  CombinatorialCode  Type  Other features    Abstract Simplicial Complexes  Simplicial Complexes  Filtered Simplicial Complexes    Directed Complexes", 
            "title": "Package Overview"
        }, 
        {
            "location": "/#library", 
            "text": "Combinatorial Codes  Public methods  Private methods    Simplicial Complexes  Public Methods  Private methods    Filtered Simplicial Complexes  Public methods  Private methods", 
            "title": "Library"
        }, 
        {
            "location": "/man/combinatorialcodes/", 
            "text": "Combinatorial Codes\n\n\nDefinition:\n A \ncombinatorial code\n $C$ is a collection $C \\subseteq 2^{[n]}$ of \ncodewords\n, subsets of the vertex set $[n] = {1,\\dots,n}$. Generally, no further structure is assumed.\n\n\n\n\nCombinatorialCode\n Type\n\n\nCombinatorial codes are represented using the \nCombinatorialCode{T}\n type. Codewords are stored as \nSet{T}\ns, where \nT\n:Integer\n\n\njulia\n C = CombinatorialCode([[],[1],[1,2],[2,3]])\nSimplicial.CombinatorialCode{Int8}\nCode on [3] with 4 codewords\nC = {emptyset, 1, 1 2, 2 3}\n\n\n\n\nBy default, when a code is constructed, the smallest \nInt\n type that can store all the vertices. To use \nUInt\n types, pass the keyword argument \nsigned=false\n. To override the integer type, pass \nsquash_int_type=false\n to the constructor.\n\n\njulia\n D = CombinatorialCode([[],[1],[1,2],[2,3]], signed=false)\nSimplicial.CombinatorialCode{UInt8}\nCode on [3] with 4 codewords\nC = {emptyset, 1, 1 2, 2 3}\n\n\njulia\n D = CombinatorialCode([[],[1],[1,2],[2,3]], squash_int_type=false)\nSimplicial.CombinatorialCode{Int64}\nCode on [3] with 4 codewords\nC = {emptyset, 1, 1 2, 2 3}\n\n\n\n\n\n\nOther features\n\n\nCombinatorialCode\ns are \niterable\n:\n\n\njulia\n [length(c) for c in C]\n4-element Array{Int64,1}:\n 0\n 1\n 2\n 2\n\n\n\n\nA complete list of methods can be found \nhere\n.", 
            "title": "Combinatorial Codes"
        }, 
        {
            "location": "/man/combinatorialcodes/#combinatorial-codes", 
            "text": "Definition:  A  combinatorial code  $C$ is a collection $C \\subseteq 2^{[n]}$ of  codewords , subsets of the vertex set $[n] = {1,\\dots,n}$. Generally, no further structure is assumed.", 
            "title": "Combinatorial Codes"
        }, 
        {
            "location": "/man/combinatorialcodes/#combinatorialcode-type", 
            "text": "Combinatorial codes are represented using the  CombinatorialCode{T}  type. Codewords are stored as  Set{T} s, where  T :Integer  julia  C = CombinatorialCode([[],[1],[1,2],[2,3]])\nSimplicial.CombinatorialCode{Int8}\nCode on [3] with 4 codewords\nC = {emptyset, 1, 1 2, 2 3}  By default, when a code is constructed, the smallest  Int  type that can store all the vertices. To use  UInt  types, pass the keyword argument  signed=false . To override the integer type, pass  squash_int_type=false  to the constructor.  julia  D = CombinatorialCode([[],[1],[1,2],[2,3]], signed=false)\nSimplicial.CombinatorialCode{UInt8}\nCode on [3] with 4 codewords\nC = {emptyset, 1, 1 2, 2 3}\n\n\njulia  D = CombinatorialCode([[],[1],[1,2],[2,3]], squash_int_type=false)\nSimplicial.CombinatorialCode{Int64}\nCode on [3] with 4 codewords\nC = {emptyset, 1, 1 2, 2 3}", 
            "title": "CombinatorialCode Type"
        }, 
        {
            "location": "/man/combinatorialcodes/#other-features", 
            "text": "CombinatorialCode s are  iterable :  julia  [length(c) for c in C]\n4-element Array{Int64,1}:\n 0\n 1\n 2\n 2  A complete list of methods can be found  here .", 
            "title": "Other features"
        }, 
        {
            "location": "/man/simplicialcomplexes/", 
            "text": "Abstract Simplicial Complexes\n\n\nThis package provides types for \nSimplicial Complexes\n and \nFiltered Simplicial Complexes\n.\n\n\n\n\nSimplicial Complexes\n\n\nDefinition:\n A \nsimplicial complex\n $(V,\\Delta)$ is a finite set $V$, called the \nvertex set\n, together with a collection $\\Delta \\subseteq 2^{V}$ which is closed under subsets, i.e. if $\\sigma \\subseteq \\tau \\subseteq V$ are sets, and $\\tau \\in \\Delta$, then $\\sigma \\in \\Delta$. Typically $(V,D)$ is simply denoted $\\Delta$ as the vertex set is often understood. Note this definition allows \"false vertices\", i.e. vertices $v \\in V$ such that ${v}\\not\\in \\Delta$.\n\n\nSimplicial complexes are represented in \nSimplicial\n with the \nSimplicialComplex\n type.\n\n\njulia\n K = SimplicialComplex([[1,2,3],[2,4],[3,4]]);\n\njulia\n show(K)\nA 2-dimensional simplicial complex on 4 vertices 1 2 3 4\nThis complex has 3 facets:\nArray{Int16,1}[Int16[2, 4], Int16[3, 4], Int16[1, 2, 3]]\n\n\n\n\n\n\nExample Simplicial Complexes\n\n\nSeveral example simplicial complexes can be constructed by calling the appropriate function, for example\n\n\njulia\n K = TwoTorus()\nSimplicial.SimplicialComplex{Int8}\n2-dimensional simplicial complex on 7 vertices with 14 facets\n    V = {1, 2, 3, 4, 5, 6, 7}\nmax K = {1 2 4, 1 3 4, 2 3 5, 2 4 5, 1 3 6, 2 3 6, 1 5 6, 4 5 6, 1 2 7, 3 4 7, 1 5 7, 3 5 7, 2 6 7, 4 6 7}\n\n\n\n\nA complete list follows:\n\n\n#\n\n\nSimplicial.DunceHat\n \n \nMethod\n.\n\n\nDunceHat()\n\n\n\n\nA triangulation of the \ndunce hat\n\n\nsource\n\n\n#\n\n\nSimplicial.KleinBottle\n \n \nMethod\n.\n\n\nKleinBottle()\n\n\n\n\nThe minimal triangulation of the Klein bottle (8 vertices, 16 facets)\n\n\nsource\n\n\n#\n\n\nSimplicial.PoincareHomologyThreeSphere\n \n \nMethod\n.\n\n\nPoincareHomologyThreeSphere()\n\n\n\n\nA triangulation of the Poincare homology 3-sphere (16 vertices, 90 facets)\n\n\nThis is a manifold whose integral homology is identical to the ordinary 3-sphere, but it is not simply connected. In particular, its fundamental group is the binary icosahedral group, which has order 120. The triangulation given here has 16 vertices and is due to Bj\u00f6rner and Lutz [BL2000].\n\n\n[BL2000]    Anders Bj\u00f6rner and Frank H. Lutz, \u201cSimplicial manifolds, bistellar flips and a 16-vertex triangulation of the Poincar\u00e9 homology 3-sphere\u201d, Experiment. Math. 9 (2000), no. 2, 275-289.\n\n\nsource\n\n\n#\n\n\nSimplicial.TwoTorus\n \n \nMethod\n.\n\n\nTwoTorus()\n\n\n\n\nThe minimal triangulation of a two-torus (7 vertices, 14 facets)\n\n\nsource\n\n\n\n\nFiltered Simplicial Complexes\n\n\nA \nfiltered simplicial complex\n $(\\Delta,f)$ is a simplicial complex $\\Delta$ together with a \nfiltration function\n $f : \\Delta \\to R$ which is monotone, i.e. if $\\sigma \\subseteq \\tau \\in \\Delta$, then $f(\\sigma) \\le f(\\tau)$. Equivalently, a filtered simplicial complex is a sequence\n\n\n\n\n\n\\Delta_0 \\subseteq \\Delta_1 \\subseteq \\cdots \\subseteq \\Delta_t\n\n\n\n\n\nof simplicial complexes.", 
            "title": "Simplicial Complexes"
        }, 
        {
            "location": "/man/simplicialcomplexes/#abstract-simplicial-complexes", 
            "text": "This package provides types for  Simplicial Complexes  and  Filtered Simplicial Complexes .", 
            "title": "Abstract Simplicial Complexes"
        }, 
        {
            "location": "/man/simplicialcomplexes/#simplicial-complexes", 
            "text": "Definition:  A  simplicial complex  $(V,\\Delta)$ is a finite set $V$, called the  vertex set , together with a collection $\\Delta \\subseteq 2^{V}$ which is closed under subsets, i.e. if $\\sigma \\subseteq \\tau \\subseteq V$ are sets, and $\\tau \\in \\Delta$, then $\\sigma \\in \\Delta$. Typically $(V,D)$ is simply denoted $\\Delta$ as the vertex set is often understood. Note this definition allows \"false vertices\", i.e. vertices $v \\in V$ such that ${v}\\not\\in \\Delta$.  Simplicial complexes are represented in  Simplicial  with the  SimplicialComplex  type.  julia  K = SimplicialComplex([[1,2,3],[2,4],[3,4]]);\n\njulia  show(K)\nA 2-dimensional simplicial complex on 4 vertices 1 2 3 4\nThis complex has 3 facets:\nArray{Int16,1}[Int16[2, 4], Int16[3, 4], Int16[1, 2, 3]]", 
            "title": "Simplicial Complexes"
        }, 
        {
            "location": "/man/simplicialcomplexes/#example-simplicial-complexes", 
            "text": "Several example simplicial complexes can be constructed by calling the appropriate function, for example  julia  K = TwoTorus()\nSimplicial.SimplicialComplex{Int8}\n2-dimensional simplicial complex on 7 vertices with 14 facets\n    V = {1, 2, 3, 4, 5, 6, 7}\nmax K = {1 2 4, 1 3 4, 2 3 5, 2 4 5, 1 3 6, 2 3 6, 1 5 6, 4 5 6, 1 2 7, 3 4 7, 1 5 7, 3 5 7, 2 6 7, 4 6 7}  A complete list follows:  #  Simplicial.DunceHat     Method .  DunceHat()  A triangulation of the  dunce hat  source  #  Simplicial.KleinBottle     Method .  KleinBottle()  The minimal triangulation of the Klein bottle (8 vertices, 16 facets)  source  #  Simplicial.PoincareHomologyThreeSphere     Method .  PoincareHomologyThreeSphere()  A triangulation of the Poincare homology 3-sphere (16 vertices, 90 facets)  This is a manifold whose integral homology is identical to the ordinary 3-sphere, but it is not simply connected. In particular, its fundamental group is the binary icosahedral group, which has order 120. The triangulation given here has 16 vertices and is due to Bj\u00f6rner and Lutz [BL2000].  [BL2000]    Anders Bj\u00f6rner and Frank H. Lutz, \u201cSimplicial manifolds, bistellar flips and a 16-vertex triangulation of the Poincar\u00e9 homology 3-sphere\u201d, Experiment. Math. 9 (2000), no. 2, 275-289.  source  #  Simplicial.TwoTorus     Method .  TwoTorus()  The minimal triangulation of a two-torus (7 vertices, 14 facets)  source", 
            "title": "Example Simplicial Complexes"
        }, 
        {
            "location": "/man/simplicialcomplexes/#filtered-simplicial-complexes", 
            "text": "A  filtered simplicial complex  $(\\Delta,f)$ is a simplicial complex $\\Delta$ together with a  filtration function  $f : \\Delta \\to R$ which is monotone, i.e. if $\\sigma \\subseteq \\tau \\in \\Delta$, then $f(\\sigma) \\le f(\\tau)$. Equivalently, a filtered simplicial complex is a sequence   \n\\Delta_0 \\subseteq \\Delta_1 \\subseteq \\cdots \\subseteq \\Delta_t   of simplicial complexes.", 
            "title": "Filtered Simplicial Complexes"
        }, 
        {
            "location": "/man/directedcomplexes/", 
            "text": "Directed Complexes\n\n\nDefinition:\n A \ndirected complex\n $(V, D)$ is a finite set $V$, called the \nvertex set\n, together with a collection $D$ of \"proper sequences\" on $V$, closed under taking subsequences. A \"proper sequence\" is a a sequence $(v_1,v_2,\\dots,v_k)$ with $v_i \\in V$ and no $v_i$s repeated. The closure property says that if $s = (v_1,\\dots,v_k) \\in D$, then every subsequence of $s$ is also in $D$.", 
            "title": "Directed Complexes"
        }, 
        {
            "location": "/man/directedcomplexes/#directed-complexes", 
            "text": "Definition:  A  directed complex  $(V, D)$ is a finite set $V$, called the  vertex set , together with a collection $D$ of \"proper sequences\" on $V$, closed under taking subsequences. A \"proper sequence\" is a a sequence $(v_1,v_2,\\dots,v_k)$ with $v_i \\in V$ and no $v_i$s repeated. The closure property says that if $s = (v_1,\\dots,v_k) \\in D$, then every subsequence of $s$ is also in $D$.", 
            "title": "Directed Complexes"
        }, 
        {
            "location": "/lib/combinatorialcodes/", 
            "text": "Combinatorial Codes\n\n\n\n\nPublic methods\n\n\n#\n\n\nSimplicial.AbstractCombinatorialCode\n \n \nType\n.\n\n\nabstract type AbstractCombinatorialCode{T\n:Integer}\n\n\n\n\nThe abstract parent class for concrete implements of \ncombinatorial codes\n.\n\n\nsource\n\n\n#\n\n\nSimplicial.CombinatorialCode\n \n \nType\n.\n\n\nCombinatorialCode{T\n:Integer}\n\n\n\n\nA collection of subsets of $[n] = {1,...,n}$. Codewords are stored as \nSet{T}\n objects in an array.\n\n\nBy default, \nT\n is determined at object construction to be the smallest \nInt\n type that can store all the vertices; see notes below.\n\n\nConstructors\n\n\nCombinatorialCode(itr, [vertices=union(itr...)]; [squash_int_type=true], [signed=true])\n\n\n\n\nCollects the unique elements of iterable collection \nitr\n as codewords. If \nsquash_int_type\n is true, determines the smallest integer type which can store all the vertices; if \nsigned=false\n this will be a \nUInt\n type, otherwise it will be an \nInt\n type. Optional argument \nvertices\n allows creation of trivial neurons, i.e. neurons which never fire. Words are stored in graded reverse lexicographic order by their binary vector representation  (see \nlessequal_GrRevLex\n).\n\n\nCombinatorialCode(B::AbstractMatrix{Bool}; order=\nrows\n, kwargs...)\n\n\n\n\nInterprets rows of matrix \nB\n as codewords. Keyword argument \norder\n is either \nrows\n or \ncols\n to specify whether rows of \nB\n or columns of \nB\n should be interpreted as codewords.\n\n\nsource\n\n\n#\n\n\nBase.in\n \n \nMethod\n.\n\n\nin(sigma::itr, C::CombinatorialCode)\n\n\n\n\nTrue if \nsigma\n is a codeword in \nC\n\n\nsource\n\n\n#\n\n\nBase.transpose\n \n \nMethod\n.\n\n\ntranspose(C::CombinatorialCode)\n\n\n\n\nThe code obtained by transposing the matrix form of a code.\n\n\nUsage: \nC1 = transpose(C)\n or \nC1 = C'\n\n\nsource\n\n\n#\n\n\nSimplicial.BitArrayOfACombinatorialCode\n \n \nMethod\n.\n\n\nBitArrayOfACombinatorialCode(C)\n\n\n\n\n!!! Deprecated     This function is an alias to \nmatrix_form\n, use that instead.\n\n\nsource\n\n\n#\n\n\nSimplicial.add!\n \n \nMethod\n.\n\n\nadd!(C, sigma)\n\n\n\n\nIn-place version \nadd\n. Returns the resulting code.\n\n\nsource\n\n\n#\n\n\nSimplicial.add\n \n \nMethod\n.\n\n\nadd(C, sigma)\n\n\n\n\nReturn \nC\n if \nin(sigma, C)\n, otherwise construct a new code $C \u222a {sigma}$.\n\n\nsource\n\n\n#\n\n\nSimplicial.del!\n \n \nMethod\n.\n\n\ndel!(C, tau)\n\n\n\n\nIn-place version of \ndel\n. Returns the resulting code.\n\n\nsource\n\n\n#\n\n\nSimplicial.del\n \n \nMethod\n.\n\n\ndel(C, tau)\n\n\n\n\nCompute the deletion of \nsigma\n from \nC\n. Returns a new \nCombinatorialCode\n with the same vertex set.\n\n\nThe deletion is defined by $del_\u03c4(C) = {\u03c3 \u2216 \u03c4 : \u03c3 \u2208 C}$\n\n\nsource\n\n\n#\n\n\nSimplicial.link\n \n \nFunction\n.\n\n\nlink(code, sigma, tau=[])\n\n\n\n\nCompute the link of the \"on\" set \nsigma\n and the \"off\" set \ntau\n in \ncode\n, defined by\n\n\n$link_{\u03c3,\u03c4}(C) = {\u03c1 \u2286 [n] : \u03c1 \u2229 \u03c3 = \u03c1 \u2229 \u03c4 = \u2205, \u03c1 \u222a \u03c3 \u2208 C}$\n\n\nsource\n\n\n#\n\n\nSimplicial.matrix_form\n \n \nMethod\n.\n\n\nmatrix_form(C::CombinatorialCode)\n\n\n\n\nA \nBitMatrix\n representation of a code, with rows as codewords.\n\n\nOrder of returned codewords matches that in \nC.words\n; assuming no one has been messing around with \nC\n's fields, these should be sorted using \nlessequal_GrRevLex\n.\n\n\nsource\n\n\n#\n\n\nSimplicial.sparse_matrix_form\n \n \nMethod\n.\n\n\nsparse_matrix_form(C::CombinatorialCode)\n\n\n\n\nA \nSparseMatrixCSC\n representation of \nC\n with \nBool\n entries; rows as codewords.\n\n\nOrder of returned codewords matches that in \nC.words\n; assuming no one has been messing around with \nC\n's fields, these should be sorted using \nlessequal_GrRevLex\n.\n\n\nsource\n\n\n#\n\n\nSimplicial.vertices\n \n \nMethod\n.\n\n\nvertices(C::CombinatorialCode)\n\n\n\n\nReturns the vertex set of \nC\n as a \nSet\n\n\nsource\n\n\n#\n\n\nSimplicial.BernoulliRandomCode\n \n \nMethod\n.\n\n\nBernoulliRandomCode(N, Nwords, p)\n\n\n\n\nDraw \nNwords\n i.i.d. samples from the distribution on \nN\n bit words given by \nN\n independent Bernoulli trials with success probability \np\n.\n\n\nsource\n\n\n#\n\n\nSimplicial.cham\n \n \nMethod\n.\n\n\ncham(C, nu)\n\n\n\n\nReturns a vector of tuples \n(sigma,tau)\n such that \nlink(C, sigma, tau)\n is the full code on \nnu\n\n\nsource\n\n\n#\n\n\nSimplicial.intersection_completion\n \n \nMethod\n.\n\n\nintersection_completion(C)\n\n\n\n\nA new code consisting of all intersections of one or more codewords of \nC\n.\n\n\nsource\n\n\n#\n\n\nSimplicial.max_intersection_completion\n \n \nMethod\n.\n\n\nmax_intersection_completion(C)\n\n\n\n\nA new code consisting of all intersections of one or more maximal codewords of \nC\n.\n\n\nsource\n\n\n#\n\n\nSimplicial.union_completion\n \n \nMethod\n.\n\n\nunion_completion(C)\n\n\n\n\nThe union-completion of a combinatorial code \nC\n, which is \nC\n together with\n\n\nsource\n\n\n#\n\n\nSimplicial.union_product\n \n \nMethod\n.\n\n\nunion_product(C1, C2)\n\n\n\n\nCompute the union product of codes \nC1\n and \nC2\n, under the GrRevLex ordering on both codes.\n\n\nFor $A = {a_1,...,a_m}$ a code on $[d]$ and $B = {b_1,...,b_d}$ a code on $[n]$, the union product is a code on $[n]$ defined by $A \u2228 B = { \u22c3_{j \u2208 a_i} b_j : a_i \u2208 A}$\n\n\nMore simply, this is the code obtained from the nonzero entries of the product of the matrix forms of $A$ and $B$.\n\n\nsource\n\n\n#\n\n\nSimplicial.PseudoMonomial\n \n \nType\n.\n\n\nPseudoMonomial\n\n\n\n\nA polynomial of the form $\u220f\n{i\u2208\u03c3} x_i \u220f\n (1 - x_j)$\n\n\nsource\n\n\n#\n\n\nSimplicial.PseudoMonomialType\n \n \nMethod\n.\n\n\nPseudoMonomialType(p::PseudoMonomial)\n\n\n\n\nReturn the type of \np\n as classified in \nthe neural ring paper\n as an \nInt\n.\n\n\nType I:   $\u03c3 \u2260 \u2205, \u03c4 = \u2205$ Type II:  $\u03c3 \u2260 \u2205, \u03c4 \u2260 \u2205$ Type III: $\u03c3 = \u2205, \u03c4 \u2260 \u2205$\n\n\nsource\n\n\n#\n\n\nSimplicial.canonical_form\n \n \nMethod\n.\n\n\ncanonical_form(C::AbstractCombinatorialCode)\n\n\n\n\nThe set of minimal psuedomonomials that generate the ideal $I_C$. See \nThe Neural Ring\n. Per the conventions of that paper, this set excludes the \"boolean relations\" $x_i(1-x_i)$. Returns a \nVector\n of \nPseudoMonomial\ns\n\n\nThis is an implementation of Algorithm 1 from \nthis paper\n\n\nsource\n\n\n\n\nPrivate methods\n\n\nTo use these functions, you'll have to call \nSimplicial.function_name()", 
            "title": "`CombinatorialCode`"
        }, 
        {
            "location": "/lib/combinatorialcodes/#combinatorial-codes", 
            "text": "", 
            "title": "Combinatorial Codes"
        }, 
        {
            "location": "/lib/combinatorialcodes/#public-methods", 
            "text": "#  Simplicial.AbstractCombinatorialCode     Type .  abstract type AbstractCombinatorialCode{T :Integer}  The abstract parent class for concrete implements of  combinatorial codes .  source  #  Simplicial.CombinatorialCode     Type .  CombinatorialCode{T :Integer}  A collection of subsets of $[n] = {1,...,n}$. Codewords are stored as  Set{T}  objects in an array.  By default,  T  is determined at object construction to be the smallest  Int  type that can store all the vertices; see notes below.  Constructors  CombinatorialCode(itr, [vertices=union(itr...)]; [squash_int_type=true], [signed=true])  Collects the unique elements of iterable collection  itr  as codewords. If  squash_int_type  is true, determines the smallest integer type which can store all the vertices; if  signed=false  this will be a  UInt  type, otherwise it will be an  Int  type. Optional argument  vertices  allows creation of trivial neurons, i.e. neurons which never fire. Words are stored in graded reverse lexicographic order by their binary vector representation  (see  lessequal_GrRevLex ).  CombinatorialCode(B::AbstractMatrix{Bool}; order= rows , kwargs...)  Interprets rows of matrix  B  as codewords. Keyword argument  order  is either  rows  or  cols  to specify whether rows of  B  or columns of  B  should be interpreted as codewords.  source  #  Base.in     Method .  in(sigma::itr, C::CombinatorialCode)  True if  sigma  is a codeword in  C  source  #  Base.transpose     Method .  transpose(C::CombinatorialCode)  The code obtained by transposing the matrix form of a code.  Usage:  C1 = transpose(C)  or  C1 = C'  source  #  Simplicial.BitArrayOfACombinatorialCode     Method .  BitArrayOfACombinatorialCode(C)  !!! Deprecated     This function is an alias to  matrix_form , use that instead.  source  #  Simplicial.add!     Method .  add!(C, sigma)  In-place version  add . Returns the resulting code.  source  #  Simplicial.add     Method .  add(C, sigma)  Return  C  if  in(sigma, C) , otherwise construct a new code $C \u222a {sigma}$.  source  #  Simplicial.del!     Method .  del!(C, tau)  In-place version of  del . Returns the resulting code.  source  #  Simplicial.del     Method .  del(C, tau)  Compute the deletion of  sigma  from  C . Returns a new  CombinatorialCode  with the same vertex set.  The deletion is defined by $del_\u03c4(C) = {\u03c3 \u2216 \u03c4 : \u03c3 \u2208 C}$  source  #  Simplicial.link     Function .  link(code, sigma, tau=[])  Compute the link of the \"on\" set  sigma  and the \"off\" set  tau  in  code , defined by  $link_{\u03c3,\u03c4}(C) = {\u03c1 \u2286 [n] : \u03c1 \u2229 \u03c3 = \u03c1 \u2229 \u03c4 = \u2205, \u03c1 \u222a \u03c3 \u2208 C}$  source  #  Simplicial.matrix_form     Method .  matrix_form(C::CombinatorialCode)  A  BitMatrix  representation of a code, with rows as codewords.  Order of returned codewords matches that in  C.words ; assuming no one has been messing around with  C 's fields, these should be sorted using  lessequal_GrRevLex .  source  #  Simplicial.sparse_matrix_form     Method .  sparse_matrix_form(C::CombinatorialCode)  A  SparseMatrixCSC  representation of  C  with  Bool  entries; rows as codewords.  Order of returned codewords matches that in  C.words ; assuming no one has been messing around with  C 's fields, these should be sorted using  lessequal_GrRevLex .  source  #  Simplicial.vertices     Method .  vertices(C::CombinatorialCode)  Returns the vertex set of  C  as a  Set  source  #  Simplicial.BernoulliRandomCode     Method .  BernoulliRandomCode(N, Nwords, p)  Draw  Nwords  i.i.d. samples from the distribution on  N  bit words given by  N  independent Bernoulli trials with success probability  p .  source  #  Simplicial.cham     Method .  cham(C, nu)  Returns a vector of tuples  (sigma,tau)  such that  link(C, sigma, tau)  is the full code on  nu  source  #  Simplicial.intersection_completion     Method .  intersection_completion(C)  A new code consisting of all intersections of one or more codewords of  C .  source  #  Simplicial.max_intersection_completion     Method .  max_intersection_completion(C)  A new code consisting of all intersections of one or more maximal codewords of  C .  source  #  Simplicial.union_completion     Method .  union_completion(C)  The union-completion of a combinatorial code  C , which is  C  together with  source  #  Simplicial.union_product     Method .  union_product(C1, C2)  Compute the union product of codes  C1  and  C2 , under the GrRevLex ordering on both codes.  For $A = {a_1,...,a_m}$ a code on $[d]$ and $B = {b_1,...,b_d}$ a code on $[n]$, the union product is a code on $[n]$ defined by $A \u2228 B = { \u22c3_{j \u2208 a_i} b_j : a_i \u2208 A}$  More simply, this is the code obtained from the nonzero entries of the product of the matrix forms of $A$ and $B$.  source  #  Simplicial.PseudoMonomial     Type .  PseudoMonomial  A polynomial of the form $\u220f {i\u2208\u03c3} x_i \u220f  (1 - x_j)$  source  #  Simplicial.PseudoMonomialType     Method .  PseudoMonomialType(p::PseudoMonomial)  Return the type of  p  as classified in  the neural ring paper  as an  Int .  Type I:   $\u03c3 \u2260 \u2205, \u03c4 = \u2205$ Type II:  $\u03c3 \u2260 \u2205, \u03c4 \u2260 \u2205$ Type III: $\u03c3 = \u2205, \u03c4 \u2260 \u2205$  source  #  Simplicial.canonical_form     Method .  canonical_form(C::AbstractCombinatorialCode)  The set of minimal psuedomonomials that generate the ideal $I_C$. See  The Neural Ring . Per the conventions of that paper, this set excludes the \"boolean relations\" $x_i(1-x_i)$. Returns a  Vector  of  PseudoMonomial s  This is an implementation of Algorithm 1 from  this paper  source", 
            "title": "Public methods"
        }, 
        {
            "location": "/lib/combinatorialcodes/#private-methods", 
            "text": "To use these functions, you'll have to call  Simplicial.function_name()", 
            "title": "Private methods"
        }, 
        {
            "location": "/lib/simplicialcomplexes/", 
            "text": "Simplicial Complexes\n\n\n\n\nPublic Methods\n\n\n#\n\n\nSimplicial.AbstractSimplicialComplex\n \n \nType\n.\n\n\nabstract type AbstractSimplicialComplex\n\n\n\n\nThe abstract parent class for all concrete implementations of \nabstract simplicial complexes\n (a regrettable clash of terminology).\n\n\nsource\n\n\n#\n\n\nSimplicial.SimplicialComplex\n \n \nType\n.\n\n\nSimplicialComplex{T}\n\n\n\n\nStores an abstract simplicial complex with vertices of type \nT\n by storing a list of its facets.\n\n\nConstructors\n\n\nSimplicialComplex(itr, vertices=union(itr...))\n\n\n\n\nUses the maximal elements of \nitr\n as facets. Optional argument \nvertices\n can specify vertex set if some vertices do not appear as faces. The vertices are of type \neltype(vertices)\n; if this is a subtype of \nInteger\n the smallest type which can store those values is used.\n\n\nSimplicialComplex(B)\n\n\n\n\nInterprets rows of binary matrix \nB\n as codewords.\n\n\nsource\n\n\n#\n\n\nSimplicial.add\n \n \nMethod\n.\n\n\nadd(K::SimplicialComplex, sigma)\n\n\n\n\nAdd face \nsigma\n to simplicial complex \nK\n. If \nsigma\n is already a face of \nK\n, returns \nK\n, otherwise returns a new object.\n\n\nsource\n\n\n#\n\n\nSimplicial.del!\n \n \nMethod\n.\n\n\ndel!(K, tau)\n\n\n\n\nIn-place version of \ndel\n\n\nsource\n\n\n#\n\n\nSimplicial.del\n \n \nMethod\n.\n\n\ndel(K, tau)\n\n\n\n\nThe deletion of \ntau\n from \nK\n. This is the set faces in \nK\n which are \nnot\n cofaces of \ntau\n. Returned complex has same vertex type and vertex set as \nK\n.\n\n\n$del_\u03c4(K) = {\u03c3 \u2208 K : \u03c4 \u228f\u0338 \u03c3}$\n\n\nFor \"deletion\" in the sense \"faces which do not intersect \ntau\n\", compute the complement of \ntau\n in \nK\n's vertex set and use \nres\n to restrict to that set.\n\n\nsource\n\n\n#\n\n\nSimplicial.dim\n \n \nMethod\n.\n\n\ndim(K)\n\n\n\n\nThe dimension of \nK\n, defined as the maximum size of a face of \nK\n minus 1.\n\n\nIf \nK\n is the void complex (i.e. \nK\n has no faces), returns \n-2\n for type stability (this function always returns an \nInt\n); mathematically a sensible value would be \n-Inf\n.\n\n\nsource\n\n\n#\n\n\nSimplicial.dimension\n \n \nFunction\n.\n\n\ndimension(K)\n\n\n\n\nAlias for \ndim\n\n\nsource\n\n\n#\n\n\nSimplicial.fvector\n \n \nMethod\n.\n\n\nfvector(K)\n\n\n\n\nCompute the f-vector of the given simplicial complex.\n\n\nThe f-vector of a simplicial complex is the vector $(f_0, f_1, ..., f_{d+1})$ where $f_i$ is the number of faces of cardinality $i$ (i.e. dimension $i - 1$).\n\n\nsource\n\n\n#\n\n\nSimplicial.hvector\n \n \nMethod\n.\n\n\nhvector(K)\nhvector(fv)\n\n\n\n\nCompute the h-vector of complex \nK\n by calling \nfvector(K)\n, or compute the h-vector corresponding to vector \nfv\n.\n\n\nSee \nfvector\n for details on the f-vector of a simplicial complex. The f-polynomial is the polynomial $F(x)$ with coefficient $f_i$ in degree $d+1-i$; the h-vector is the coefficients of $F(x-1)$ in decreasing order of degree.\n\n\nsource\n\n\n#\n\n\nSimplicial.link\n \n \nMethod\n.\n\n\nlink(K::SimplicialComplex, sigma)\n\n\n\n\nThe link of \nsigma\n in \nK\n.\n\n\n$link_\u03c3(K) = {\u03c4 \u2208 K : \u03c3 \u2229 \u03c4 = \u2205, \u03c3 \u222a \u03c4 \u2208 K}$\n\n\nsource\n\n\n#\n\n\nSimplicial.res\n \n \nMethod\n.\n\n\nres(K, Vprime)\n\n\n\n\nThe restriction of \nK\n to \nVprime\n.\n\n\n$res_{V'}(K) = {\u03c3 \u2208 K : \u03c3 \u2286 V'} = {\u03c3 \u2229 V' : \u03c3 \u2208 K}$\n\n\nsource\n\n\n#\n\n\nSimplicial.IrrelevantComplex\n \n \nMethod\n.\n\n\nIrrelevantComplex(vertices=Set{Int}())\nIrrelevantComplex(K::AbstractSimplicialComplex)\n\n\n\n\nThe irrelevant complex, which has exactly one face, the empty set. Vertex set can be optionally specified\n\n\nThe second form returns a simplicial complex of the same type and vertex set as \nK\n.\n\n\nsource\n\n\n#\n\n\nSimplicial.VoidComplex\n \n \nMethod\n.\n\n\nVoidComplex(vertices=Set{Int}())\nVoidComplex(K::AbstractSimplicialComplex)\n\n\n\n\nThe void simplicial complex, which has no faces (not even the empty set), with specified vertex set (default is empty).\n\n\nThe second form returns a simplicial complex of the same type and vertex set as \nK\n\n\nsource\n\n\n#\n\n\nSimplicial.alexander_dual\n \n \nMethod\n.\n\n\nalexader_dual(SC::SimplicialComplex)\n\n\n\n\nReturns the Alexander dual simplicial complex to \nSC\n.\n\n\n$dual \u0394 = {V \u2216 c : c \u2209 \u0394}$\n\n\n!!! Implementation note     Currently uses a highly inefficient algorithm, unsuitable for larger complexes.\n\n\nsource\n\n\n\n\nPrivate methods\n\n\nTo use these functions, you'll have to call \nSimplicial.function_name()\n\n\n#\n\n\nSimplicial.DeleteRedundantFacets!\n \n \nMethod\n.\n\n\nDeleteRedundantFacets!(facets::Vector)\n\n\n\n\nDeletes redundant sets in \nfacets\n in-place. A set is redundant if it is a subset (or equal to) a later set.\n\n\nsource", 
            "title": "`SimplicialComplex`"
        }, 
        {
            "location": "/lib/simplicialcomplexes/#simplicial-complexes", 
            "text": "", 
            "title": "Simplicial Complexes"
        }, 
        {
            "location": "/lib/simplicialcomplexes/#public-methods", 
            "text": "#  Simplicial.AbstractSimplicialComplex     Type .  abstract type AbstractSimplicialComplex  The abstract parent class for all concrete implementations of  abstract simplicial complexes  (a regrettable clash of terminology).  source  #  Simplicial.SimplicialComplex     Type .  SimplicialComplex{T}  Stores an abstract simplicial complex with vertices of type  T  by storing a list of its facets.  Constructors  SimplicialComplex(itr, vertices=union(itr...))  Uses the maximal elements of  itr  as facets. Optional argument  vertices  can specify vertex set if some vertices do not appear as faces. The vertices are of type  eltype(vertices) ; if this is a subtype of  Integer  the smallest type which can store those values is used.  SimplicialComplex(B)  Interprets rows of binary matrix  B  as codewords.  source  #  Simplicial.add     Method .  add(K::SimplicialComplex, sigma)  Add face  sigma  to simplicial complex  K . If  sigma  is already a face of  K , returns  K , otherwise returns a new object.  source  #  Simplicial.del!     Method .  del!(K, tau)  In-place version of  del  source  #  Simplicial.del     Method .  del(K, tau)  The deletion of  tau  from  K . This is the set faces in  K  which are  not  cofaces of  tau . Returned complex has same vertex type and vertex set as  K .  $del_\u03c4(K) = {\u03c3 \u2208 K : \u03c4 \u228f\u0338 \u03c3}$  For \"deletion\" in the sense \"faces which do not intersect  tau \", compute the complement of  tau  in  K 's vertex set and use  res  to restrict to that set.  source  #  Simplicial.dim     Method .  dim(K)  The dimension of  K , defined as the maximum size of a face of  K  minus 1.  If  K  is the void complex (i.e.  K  has no faces), returns  -2  for type stability (this function always returns an  Int ); mathematically a sensible value would be  -Inf .  source  #  Simplicial.dimension     Function .  dimension(K)  Alias for  dim  source  #  Simplicial.fvector     Method .  fvector(K)  Compute the f-vector of the given simplicial complex.  The f-vector of a simplicial complex is the vector $(f_0, f_1, ..., f_{d+1})$ where $f_i$ is the number of faces of cardinality $i$ (i.e. dimension $i - 1$).  source  #  Simplicial.hvector     Method .  hvector(K)\nhvector(fv)  Compute the h-vector of complex  K  by calling  fvector(K) , or compute the h-vector corresponding to vector  fv .  See  fvector  for details on the f-vector of a simplicial complex. The f-polynomial is the polynomial $F(x)$ with coefficient $f_i$ in degree $d+1-i$; the h-vector is the coefficients of $F(x-1)$ in decreasing order of degree.  source  #  Simplicial.link     Method .  link(K::SimplicialComplex, sigma)  The link of  sigma  in  K .  $link_\u03c3(K) = {\u03c4 \u2208 K : \u03c3 \u2229 \u03c4 = \u2205, \u03c3 \u222a \u03c4 \u2208 K}$  source  #  Simplicial.res     Method .  res(K, Vprime)  The restriction of  K  to  Vprime .  $res_{V'}(K) = {\u03c3 \u2208 K : \u03c3 \u2286 V'} = {\u03c3 \u2229 V' : \u03c3 \u2208 K}$  source  #  Simplicial.IrrelevantComplex     Method .  IrrelevantComplex(vertices=Set{Int}())\nIrrelevantComplex(K::AbstractSimplicialComplex)  The irrelevant complex, which has exactly one face, the empty set. Vertex set can be optionally specified  The second form returns a simplicial complex of the same type and vertex set as  K .  source  #  Simplicial.VoidComplex     Method .  VoidComplex(vertices=Set{Int}())\nVoidComplex(K::AbstractSimplicialComplex)  The void simplicial complex, which has no faces (not even the empty set), with specified vertex set (default is empty).  The second form returns a simplicial complex of the same type and vertex set as  K  source  #  Simplicial.alexander_dual     Method .  alexader_dual(SC::SimplicialComplex)  Returns the Alexander dual simplicial complex to  SC .  $dual \u0394 = {V \u2216 c : c \u2209 \u0394}$  !!! Implementation note     Currently uses a highly inefficient algorithm, unsuitable for larger complexes.  source", 
            "title": "Public Methods"
        }, 
        {
            "location": "/lib/simplicialcomplexes/#private-methods", 
            "text": "To use these functions, you'll have to call  Simplicial.function_name()  #  Simplicial.DeleteRedundantFacets!     Method .  DeleteRedundantFacets!(facets::Vector)  Deletes redundant sets in  facets  in-place. A set is redundant if it is a subset (or equal to) a later set.  source", 
            "title": "Private methods"
        }, 
        {
            "location": "/lib/filteredsimplicialcomplexes/", 
            "text": "Filtered Simplicial Complexes\n\n\n\n\nPublic methods\n\n\n\n\nPrivate methods\n\n\nTo use these functions, you'll have to call \nSimplicial.function_name()", 
            "title": "`FiltrationOfSimplicialComplexes`"
        }, 
        {
            "location": "/lib/filteredsimplicialcomplexes/#filtered-simplicial-complexes", 
            "text": "", 
            "title": "Filtered Simplicial Complexes"
        }, 
        {
            "location": "/lib/filteredsimplicialcomplexes/#public-methods", 
            "text": "", 
            "title": "Public methods"
        }, 
        {
            "location": "/lib/filteredsimplicialcomplexes/#private-methods", 
            "text": "To use these functions, you'll have to call  Simplicial.function_name()", 
            "title": "Private methods"
        }, 
        {
            "location": "/lib/directedcomplexes/", 
            "text": "Directed Complexes\n\n\n\n\nPublic methods\n\n\n#\n\n\nSimplicial.DirectedCodeword\n \n \nType\n.\n\n\nDirectedCodeword is the type that encodes (ordered) sequences of vertices\n\n\nsource\n\n\n#\n\n\nSimplicial.DirectedComplex\n \n \nMethod\n.\n\n\nThis function takes a matrix (of integers or Floats and produces a directed complex )\n\n\nsource\n\n\n#\n\n\nBase.:\n=\n \n \nMethod\n.\n\n\nissubsequence(a,b) a.k.a. \n=(a,b)  determines if the sequence a is a subsequence of sequence b\n\n\nsource\n\n\n#\n\n\nSimplicial.Matrix2Permutations\n \n \nMethod\n.\n\n\nfunction  Matrix2Permutations(A::Matrix)::Matrix   This utility function takes a matrix A of real numbers and returns the matrix RowOrdering of integers, so that   RowOrdering[i,j] = the order of the element A[i,j] in the i-th row of A   Usage: RowOrdering=Matrix2Permutations(A);\n\n\nsource\n\n\n#\n\n\nSimplicial.issubsequence\n \n \nMethod\n.\n\n\nThe following name added for compartibility with the older code\n\n\nsource\n\n\n#\n\n\nSimplicial.BettiNumbers\n \n \nFunction\n.\n\n\nbeta=BettiNumbers(D::DirectedComplex,maximaldimension=Inf)\n\n\nThis function returns the Betti numbers of the homology of a (so far only pure) directed complex\n\n\nThis is a very crude way to compute directed homology \u2013 this does not use any tricks, just the definition and the built-in rank function that may fail to work properly on large enough matrices. Use with caution. Works as prescribed on small enough complexes.\n\n\nHere the length of beta is equal to maximaldimension+1, beta[1] is 0-th Betti number  and beta[P.dim+1] is the P.dim-dimensional Betti number maximaldimension is an optional parameter to restrict the maximal possible dimension of homology to compute\n\n\nsource\n\n\n\n\nPrivate methods\n\n\nTo use these functions, you'll have to call \nSimplicial.function_name()\n\n\n#\n\n\nSimplicial.FiltrationOfSimplicialComplexes\n \n \nType\n.\n\n\ntype FiltrationOfSimplicialComplexes.   This is the type that we use for the increasing fitrations of simplicial complexes\n\n\nsource\n\n\n#\n\n\nSimplicial.DowkerComplex\n \n \nFunction\n.\n\n\nDowkerComplex(A,maxdensity=1)\n\nThis returns the Dowker complex of a rectangular matrix A\nNormal usage of this function should be\n\nFS, GraphDensity=DowkerComplex(A);\nor\nFS, GraphDensity=DowkerComplex(A,maxdensity);\n\nHere FS is of the type FiltrationOfSimplicialComplexes\nAnd GraphDensity is an array of real numbers of length =F.depth\nwhere each number GraphDensity[i] represents the graph density at the simplicial complex Delta_i in the filtration\n\n\n\n\nsource\n\n\n#\n\n\nSimplicial.Skeleton\n \n \nMethod\n.\n\n\nSkeleton(FS::FiltrationOfSimplicialComplexes,dim::Int)::FiltrationOfSimplicialComplexes\nThis Funcion takes a filtration of simplicial complexes and produces a filtration of their skeletons\n\n\n\n\nsource\n\n\n#\n\n\nSimplicial.Skeleton_OLD\n \n \nMethod\n.\n\n\nSkeleton_OLD(FS::FiltrationOfSimplicialComplexes,dim::Int)::FiltrationOfSimplicialComplexes\nThis Function takes a filtration of simplicial complexes and produces a filtration of their skeletons\nThis implementation is \nnaive\n, old and very inefficient on large skeleta\n\n\n\n\nsource\n\n\n#\n\n\nSimplicial.FaceBirthpush!\n \n \nMethod\n.\n\n\nFaceBirthpush!(ListOfFaces::Array{CodeWord,1},births::Array{Int,1},AddedFace::CodeWord,AssignedBirth::Int)\n\n\n\n\nsource", 
            "title": "`DirectedComplex`"
        }, 
        {
            "location": "/lib/directedcomplexes/#directed-complexes", 
            "text": "", 
            "title": "Directed Complexes"
        }, 
        {
            "location": "/lib/directedcomplexes/#public-methods", 
            "text": "#  Simplicial.DirectedCodeword     Type .  DirectedCodeword is the type that encodes (ordered) sequences of vertices  source  #  Simplicial.DirectedComplex     Method .  This function takes a matrix (of integers or Floats and produces a directed complex )  source  #  Base.: =     Method .  issubsequence(a,b) a.k.a.  =(a,b)  determines if the sequence a is a subsequence of sequence b  source  #  Simplicial.Matrix2Permutations     Method .  function  Matrix2Permutations(A::Matrix)::Matrix   This utility function takes a matrix A of real numbers and returns the matrix RowOrdering of integers, so that   RowOrdering[i,j] = the order of the element A[i,j] in the i-th row of A   Usage: RowOrdering=Matrix2Permutations(A);  source  #  Simplicial.issubsequence     Method .  The following name added for compartibility with the older code  source  #  Simplicial.BettiNumbers     Function .  beta=BettiNumbers(D::DirectedComplex,maximaldimension=Inf)  This function returns the Betti numbers of the homology of a (so far only pure) directed complex  This is a very crude way to compute directed homology \u2013 this does not use any tricks, just the definition and the built-in rank function that may fail to work properly on large enough matrices. Use with caution. Works as prescribed on small enough complexes.  Here the length of beta is equal to maximaldimension+1, beta[1] is 0-th Betti number  and beta[P.dim+1] is the P.dim-dimensional Betti number maximaldimension is an optional parameter to restrict the maximal possible dimension of homology to compute  source", 
            "title": "Public methods"
        }, 
        {
            "location": "/lib/directedcomplexes/#private-methods", 
            "text": "To use these functions, you'll have to call  Simplicial.function_name()  #  Simplicial.FiltrationOfSimplicialComplexes     Type .  type FiltrationOfSimplicialComplexes.   This is the type that we use for the increasing fitrations of simplicial complexes  source  #  Simplicial.DowkerComplex     Function .  DowkerComplex(A,maxdensity=1)\n\nThis returns the Dowker complex of a rectangular matrix A\nNormal usage of this function should be\n\nFS, GraphDensity=DowkerComplex(A);\nor\nFS, GraphDensity=DowkerComplex(A,maxdensity);\n\nHere FS is of the type FiltrationOfSimplicialComplexes\nAnd GraphDensity is an array of real numbers of length =F.depth\nwhere each number GraphDensity[i] represents the graph density at the simplicial complex Delta_i in the filtration  source  #  Simplicial.Skeleton     Method .  Skeleton(FS::FiltrationOfSimplicialComplexes,dim::Int)::FiltrationOfSimplicialComplexes\nThis Funcion takes a filtration of simplicial complexes and produces a filtration of their skeletons  source  #  Simplicial.Skeleton_OLD     Method .  Skeleton_OLD(FS::FiltrationOfSimplicialComplexes,dim::Int)::FiltrationOfSimplicialComplexes\nThis Function takes a filtration of simplicial complexes and produces a filtration of their skeletons\nThis implementation is  naive , old and very inefficient on large skeleta  source  #  Simplicial.FaceBirthpush!     Method .  FaceBirthpush!(ListOfFaces::Array{CodeWord,1},births::Array{Int,1},AddedFace::CodeWord,AssignedBirth::Int)  source", 
            "title": "Private methods"
        }
    ]
}